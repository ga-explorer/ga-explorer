<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>DSL &#8211; Geometric Algebra Explorer</title>
	<atom:link href="/index.php/tag/dsl/feed/" rel="self" type="application/rss+xml" />
	<link>/</link>
	<description>Voyaging the Computational Universe with Geometric Algebra</description>
	<lastBuildDate>Tue, 07 Nov 2017 06:57:43 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.8.3</generator>

<image>
	<url>/wp-content/uploads/2016/12/cropped-GAExplorer-Icon-150x150.jpg</url>
	<title>DSL &#8211; Geometric Algebra Explorer</title>
	<link>/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>GMac: The Next Generation (2 of 2)</title>
		<link>/index.php/2017/02/10/gmac-tng-2/</link>
		<pubDate>Fri, 10 Feb 2017 03:00:04 +0000</pubDate>
		<dc:creator><![CDATA[Ahmad Eid]]></dc:creator>
				<category><![CDATA[GA Software]]></category>
		<category><![CDATA[GMac]]></category>
		<category><![CDATA[Compiler]]></category>
		<category><![CDATA[Computer Algebra]]></category>
		<category><![CDATA[Development]]></category>
		<category><![CDATA[Development Environment]]></category>
		<category><![CDATA[Domain Specific]]></category>
		<category><![CDATA[DSL]]></category>
		<category><![CDATA[Geometric Algebra]]></category>
		<category><![CDATA[GMacAPI]]></category>
		<category><![CDATA[GMacAST]]></category>
		<category><![CDATA[GMacDSL]]></category>
		<category><![CDATA[Irony Framework]]></category>
		<category><![CDATA[Mathematica]]></category>
		<category><![CDATA[Parsing]]></category>
		<category><![CDATA[Scripting]]></category>
		<category><![CDATA[Semantic Analysis]]></category>
		<category><![CDATA[TextComposerLib]]></category>

		<guid isPermaLink="false">https://gacomputing.info/?p=2531</guid>
		<description><![CDATA[<p>Planning for the next generation of GMac began in August 2011. I started to design the new version of GMac from scratch by reading significant parts of Terence Parr's book "Language Implementation Patterns", Robert W. Sebesta's classic book "Concepts of Programming Languages", and the second edition of the bestseller Dragon Book "Compilers: Principles, Techniques, and Tools". I had learned many lessons during developing the first GMac prototype. These books provided a solid conceptual framework for designing the new version of GMac containing all the lessons I'd learned before.<br />
In the previous post, I talked about the first part of my journey developing GMac, the fascinating discoveries I made, and the difficulties I faced along the way. In this final part, I explain the design decisions I made for GMac and how I came to select them, in addition to the developments I hope to make in the future.</p>
<p>The post <a rel="nofollow" href="/index.php/2017/02/10/gmac-tng-2/">GMac: The Next Generation (2 of 2)</a> appeared first on <a rel="nofollow" href="/">Geometric Algebra Explorer</a>.</p>
]]></description>
				<content:encoded><![CDATA[<p><a href="/wp-content/uploads/2017/02/Arches.jpg"><img class="aligncenter size-large wp-image-2539" src="/wp-content/uploads/2017/02/Arches-1024x768.jpg" alt="Arches" width="1024" height="768" srcset="/wp-content/uploads/2017/02/Arches-1024x768.jpg 1024w, /wp-content/uploads/2017/02/Arches-300x225.jpg 300w, /wp-content/uploads/2017/02/Arches-768x576.jpg 768w, /wp-content/uploads/2017/02/Arches.jpg 1280w" sizes="(max-width: 1024px) 100vw, 1024px" /></a></p>
<blockquote><p>There are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies, and the other way is to make it so complicated that there are no obvious deficiencies. The first method is far more difficult. &#8212; C. A. R. Hoare.</p></blockquote>
<span class="dropcap">P</span>lanning for the next generation of GMac began in August 2011. I started to design the new version of GMac from scratch by reading significant parts of Terence Parr&#8217;s book &#8220;<a href="https://pragprog.com/book/tpdsl/language-implementation-patterns" target="_blank" rel="noopener">Language Implementation Patterns</a>&#8221; <sup class='endnote'><a href='#en-2531-1' id='enref-2531-1' onclick='return hhEndnotes_show(2531)'>1</a></sup>, Robert W. Sebesta&#8217;s classic book &#8220;<a href="https://www.amazon.com/Concepts-Programming-Languages-Robert-Sebesta/dp/0131395319" target="_blank" rel="noopener">Concepts of Programming Languages</a>&#8220;, and the second edition of the bestseller <a href="https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools" target="_blank" rel="noopener">Dragon Book</a> &#8220;<a href="https://www.amazon.com/Compilers-Principles-Techniques-Tools-2nd/dp/0321486811/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1486586482&amp;sr=1-1&amp;keywords=compiler+design" target="_blank" rel="noopener">Compilers: Principles, Techniques, and Tools</a>&#8220;. I had learned many lessons during developing the first GMac prototype. These books provided a solid conceptual framework for designing the new version of GMac containing all the lessons I&#8217;d learned before.</p>
<p>In the <a href="/index.php/2017/02/09/gmac-tng-1/" target="_blank" rel="noopener">previous post</a>, I talked about the first part of my journey developing GMac, the fascinating discoveries I made, and the difficulties I faced along the way. In this final part, I explain the design decisions I made for GMac and how I came to select them, in addition to the developments I hope to make in the future.</p>
<h3>Having a Symbolic Value</h3>
<blockquote><p>&#8230; with proper design, the features come cheaply. This approach is arduous, but continues to succeed. &#8211;Dennis Ritchie.</p></blockquote>
<p><a href="/wp-content/uploads/2017/02/Equations.jpg"><img class="alignright size-medium wp-image-2523" src="/wp-content/uploads/2017/02/Equations-300x200.jpg" alt="Equations" width="300" height="200" srcset="/wp-content/uploads/2017/02/Equations-300x200.jpg 300w, /wp-content/uploads/2017/02/Equations.jpg 640w" sizes="(max-width: 300px) 100vw, 300px" /></a></p>
<p>The first line of code I wrote was in the most basic of its foundations; namely the interface between GMac and a mathematical symbolic processing system like Mathematica. In addition, I created a library of utilities and basic data structures that grew over time called <strong>UtilsLib</strong>. I initially started out trying to design a single library that is capable of unifying and handling symbolic processing for a number of <a href="https://en.wikipedia.org/wiki/Computer_algebra_system" target="_blank" rel="noopener"><strong>Computer Algebra Systems</strong></a> <strong>(CAS)</strong> like <a href="https://www.wolfram.com/mathematica/" target="_blank" rel="noopener">Mathematica</a>, <a href="https://www.maplesoft.com/products/maple/" target="_blank" rel="noopener">Maple</a>, <a href="https://www.ptc.com/en/products/mathcad" target="_blank" rel="noopener">Mathcad</a>, <a href="http://www.sagemath.org/" target="_blank" rel="noopener">SageMath</a>, <a href="http://maxima.sourceforge.net/" target="_blank" rel="noopener">Maxima</a>, etc. In order to create such class library, I would have to learn the basics of all these systems to abstract a common interface. This was a huge project by itself that would delay my dream considerably. I eventually concentrated on designing an Object Oriented (OO) interface to <a href="http://reference.wolfram.com/language/NETLink/tutorial/Overview.html" target="_blank" rel="noopener">Mathematica&#8217;s NET Link API</a> in the hope that I would have the time to expand it later to other symbolic processing systems.</p>
<p>Computer algebra systems mostly use homogeneous trees of objects, like Mathematica&#8217;s <a href="https://reference.wolfram.com/language/NETLink/ref/net/Wolfram.NETLink.Expr.html" target="_blank" rel="noopener">Expr class</a>, to store information about <a href="http://reference.wolfram.com/language/tutorial/EverythingIsAnExpression.html" target="_blank" rel="noopener">the structure of all their expressions</a>. These homogenous trees are suitable for computer algebra but not easy to handle using OO design. This is a similar problem to needing an OO interface between tables in relational databases and the OO applications interacting with them, we call that the <strong><a href="https://en.wikipedia.org/wiki/Data_access_layer" target="_blank" rel="noopener">Data Access Layer</a> (DAL)</strong>.</p>
<p>The final result is my <strong><a href="https://gmac-guides.netlify.com/index.php/gmac-math-guide/" target="_blank" rel="noopener">SymbolicInterface</a></strong> component class library, a kind of <strong>Symbolic Processing Access Layer (SPAL)</strong> to Mathematica. The main purpose of this library is to add low-level symbolic processing capabilities to GMac on symbolic scalars. A symbolic scalar is the most basic unit of computation that GMac can handle; it represents an expression that can be evaluated into a real number after substituting values into its symbolic variables if any are present. For example, all the following are basic symbolic scalars in GMac based on Mathematica syntax for symbolic expressions:</p>
<ul>
<li>-109</li>
<li>2.3456</li>
<li>Rational[6,11]</li>
<li>Pi</li>
<li>Sin[2*Pi/3]</li>
<li>Exp[-t/5]</li>
<li>x + 3 * Power[y, 2] &#8211; 5 x * y</li>
</ul>
<p>The restrictions on the Mathematica values and functions used in scalar expressions is that each value or function should be convertible into the target language in which code generation is desired. Each symbolic variable, like x, y, and t in the above expressions, should be associated with a data store in the target code; for example, a local variable, an array element, a class member, a named constant etc. Additional kinds of symbolic expressions with unified OO interfaces can be defined and evaluated like matrices, vectors, boolean expressions, rules, etc.</p>
<p>Using the SymbolicInterface classes I could now define basic operations on multivectors in any selected GA frame. I could define symbolic basis blades and their linear combinations using an approach similar to the one described in &#8220;<a href="https://www.amazon.com/Geometric-Algebra-Computer-Science-Revised/dp/0123749425" target="_blank" rel="noopener">Geometric Algebra for Computer Science</a>&#8220;. I could create and manipulate symbolic multivectors as linear combinations of basis blades with any given signature, even non-orthogonal ones like the 5D Conformal GA. The coefficients of these symbolic multivectors are symbolic scalars, not just numeric floating point numbers. I began implementing all standard operations on multivectors and blades like the geometric, outer, and inner products, inversions and involutions, outermorphisms, etc.</p>
<p>The SymbolicInterface classes are used extensively across all layers and components of GMac to communicate with Mathematica through a unified OO interface. This interface can be used in similar projects. I hope I could make it an open source component in the near future, if I could obtain proper funding for GMac, to be further developed by interested people. I also need to add automatic symbolic multivector differentiation to increase the range of applications that GMac can be used in.</p>
<h3>Being Specific</h3>
<blockquote><p>It&#8217;s OK to figure out murder mysteries, but you shouldn&#8217;t need to figure out code. You should be able to read it. &#8212; Steve McConnell.</p></blockquote>
<p><a href="/wp-content/uploads/2017/02/Coding.jpg"><img class="alignright wp-image-2526 size-medium" src="/wp-content/uploads/2017/02/Coding-300x200.jpg" alt="Coding" width="300" height="200" srcset="/wp-content/uploads/2017/02/Coding-300x200.jpg 300w, /wp-content/uploads/2017/02/Coding.jpg 640w" sizes="(max-width: 300px) 100vw, 300px" /></a>The next logical step to make was to design and implement the main user interface to the GMac system, its <strong><a href="https://en.wikipedia.org/wiki/Domain-specific_language" target="_blank" rel="noopener">Domain Specific Language</a> (DSL)</strong>. One of the lessons I&#8217;d learned during my Ph.D. was that using sophisticated software systems requires a well-designed interface close to the user&#8217;s specific domain of knowledge, not the software engineer&#8217;s. Two approaches, DSLs and <strong><a href="https://en.wikipedia.org/wiki/Visual_programming_language" target="_blank" rel="noopener">Visual Programming Languages</a> (VPLs)</strong>, are the best candidates for the job. A VPL can always be built around a DSL but would require an additional layer to visually interface with the user, So I decided to start with a simple Geometric Algebra based DSL <sup class='endnote'><a href='#en-2531-2' id='enref-2531-2' onclick='return hhEndnotes_show(2531)'>2</a></sup>. I hope in the future I could implement a visual environment for GMac that can be used to define GA-models using visual GA-notation and relate the DSL&#8217;s components together visually.</p>
<p>It took a lot of experimentation and re-design, but the final result is <a href="https://gmac-guides.netlify.com/index.php/gmacdsl-guide/" target="_blank" rel="noopener"><strong>GMacDSL</strong></a>. The language design of GMacDSL is simple and focused on the domain; namely GA-based modeling. GMacDSL is not <a href="https://en.wikipedia.org/wiki/Turing_completeness" target="_blank" rel="noopener">Turing-complete</a> because it doesn&#8217;t need to be. The main elements of GMacDSL are:</p>
<ol>
<li><strong>Namespaces:</strong> These are simple logical named containers for the other elements of GMacDSL similar ti Java packages and C# namespaces.</li>
<li><strong>Frames:</strong> Using GMacDSL, the user can define any fixed set of named basis vectors along with their relative metric relations including Euclidean, Orthonormal, Orthogonal, and Non-orthogonal frames. Frames are the basic abstraction on which all subsequent symbolic computations occur inside GMac.</li>
<li><strong>Subspaces:</strong> A subspace is a set of basis blades of a given frame. They are useful in many cases for selecting or defining parts of multivectors during symbolic computations.</li>
<li><strong>Pre-defined Data Types:</strong> Two types are present in GMacDSL. Scalars are symbolic expressions of real values, including number literals. In addition, each frame automatically defines an associated Multivector type; a list of scalars defining a symbolic linear combination of the Frame&#8217;s basis blades.</li>
<li><strong>Structures:</strong> User-defined combinations of named members having given types including scalars, multivectors, or other structures. These are similar to user-defined types and structs in other languages. The main purpose of structures is to implement the pattern of <a href="/index.php/2017/01/13/ga-computing3/" target="_blank" rel="noopener">Geometric Generators</a> in GMacDSL.</li>
<li><strong>Constants:</strong> These are constant-valued named data containers of any type including scalars, multivectors, and structures. The scalar values inside constants can be large symbolic expressions; they needn&#8217;t be number literals.</li>
<li><strong>Fixed Outermorphisms:</strong> These are simple outermorphisms with fixed scalar elements that are mainly used to transform related frames. For example, we can define a non-orthogonal frame using an orthogonal one and an invertible change of basis matrix. Then GMac automatically defines two fixed outermorphisms to transform multivectors between the two frames.</li>
<li><strong>Multivector Expressions:</strong> The main function of GMac is to handle standard GA operations on symbolic multivectors. Multivector expressions provide this capability to define macros and construct constants.</li>
<li><strong>Macros:</strong> A macro in GMacDSL is the most important unit of computation. Simply speaking, a macro is a list of GA-based high-level computations on scalars, multivectors, and structures that produce a single value of any type from computations performed on a number of inputs, also of any type. A macro is not a procedure or function in the familiar way of common programming languages. A macro can only call other macros defined before it in the DSL code and allows no recursion.</li>
</ol>
<p>This structure is simple to understand and use for non-programmers working with GA models while being sufficient for covering many practical GA models. In the future, I hope to develop GMacDSL using the <a href="https://en.wikipedia.org/wiki/Functional_programming" target="_blank" rel="noopener">Functional Programming Paradigm</a>. This would provide elegant and powerful syntax and semantics for GA-based models that would take great benefit from GA&#8217;s unified and elegant mathematical abstractions.</p>
<h3>Finding Irony</h3>
<blockquote><p>When debugging, novices insert corrective code; experts remove defective code. &#8212; Richard Pattis.</p></blockquote>
<div id="attachment_2494" style="width: 266px" class="wp-caption alignright"><a href="/wp-content/uploads/2017/02/Compiler.png"><img class="size-medium wp-image-2494" src="/wp-content/uploads/2017/02/Compiler-256x300.png" alt="Compiler" width="256" height="300" srcset="/wp-content/uploads/2017/02/Compiler-256x300.png 256w, /wp-content/uploads/2017/02/Compiler.png 378w" sizes="(max-width: 256px) 100vw, 256px" /></a><p class="wp-caption-text">Construction of a typical compiler (<a href="https://commons.wikimedia.org/wiki/File:Compilador.png" target="_blank" rel="noopener">source</a>)</p></div>
<p>In order to experiment with various designs of GMacDSL I had to implement a compiler to parse and translate GMacDSL code into a suitable intermediate data structure. In 2012, I began writing the <strong>GMacCompiler</strong> <a href="https://en.wikipedia.org/wiki/Compiler#Front_end" target="_blank" rel="noopener">front-end</a> for that purpose. The first step in creating a typical <a href="https://en.wikipedia.org/wiki/Compiler" target="_blank" rel="noopener">compiler</a> is to implement its parser. I initially tried to code my own parser using the elegant functional capabilities of <a href="http://fsharp.org/" target="_blank" rel="noopener">F#</a> but I later found a much better solution called <strong><a href="http://irony.codeplex.com/" target="_blank" rel="noopener">Irony</a> </strong>by Roman Ivantsov <sup class='endnote'><a href='#en-2531-3' id='enref-2531-3' onclick='return hhEndnotes_show(2531)'>3</a></sup>. Irony has many good features that attract computer language designers to use it as a base for their language tools. Using Irony I could easily parse GMacDSL code into a homogeneous <a href="https://en.wikipedia.org/wiki/Parse_tree" target="_blank" rel="noopener"><strong>Parse Tree</strong></a>. This parse tree is not useful by itself because it&#8217;s based on a context-free Irony Grammar, but it can be converted into a more useful <strong><a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="noopener">Abstract Syntax Tree</a> (AST)</strong> through <a href="https://www.tutorialspoint.com/compiler_design/compiler_design_semantic_analysis.htm" target="_blank" rel="noopener">semantic analysis</a>.</p>
<p>Based on Irony, I developed an infrastructure for creating simple DSLs. I call this infrastructure <strong>IronyGrammars </strong><sup class='endnote'><a href='#en-2531-4' id='enref-2531-4' onclick='return hhEndnotes_show(2531)'>4</a></sup>; it provides many services needed by typical DSL compilers like source code handling, error and warning messages reporting, <a href="https://en.wikipedia.org/wiki/Symbol_table" target="_blank" rel="noopener">symbol table</a> management, <a href="https://www.tutorialspoint.com/compiler_design/compiler_design_semantic_analysis.htm" target="_blank" rel="noopener">semantic analysis</a>, AST construction and navigation, interpretation services, etc. Naturally, the most difficult part of implementing the IronyGrammars infrastructure is the debugging. Many cycles of refactoring, testing, and debugging were made. The implementation finally settled in a relatively satisfying state after removing much code.</p>
<p>I used IronyGrammars to create the GMacCompiler front-end as a specific compiler of GMacDSL code. The GMacCompiler front-end parses and translates the GMacDSL code into the desired intermediate data structure; the <strong><a href="https://gmac-guides.netlify.com/index.php/gmacast-guide/" target="_blank" rel="noopener">GMacAST</a></strong> structure used as the primary GA-based high-level information source for further symbolic processing at later stages. I also created mini-compilers that can translate partial GMacDSL code like a single multivector expression, a single user defined structure, or a single macro. This kind of small compilers is very useful during code composition for adding temporary structure to an already created GMacAST.</p>
<h3>Caring for the Environment, Talking to Trees</h3>
<blockquote><p>Perfection (in design) is achieved not when there is nothing more to add, but rather when there is nothing more to take away. &#8212; Antoine de Saint-Exupery.</p></blockquote>
<div id="attachment_1220" style="width: 310px" class="wp-caption alignright"><a href="/wp-content/uploads/2015/11/GMacAST_MainComponents.jpeg" class="broken_link"><img class="size-medium wp-image-1220" src="/wp-content/uploads/2015/11/GMacAST_MainComponents-300x268.jpeg" alt="GMacAST Main Components" width="300" height="268" /></a><p class="wp-caption-text">GMacAST Main Components</p></div>
<p>By 2013 I had a solid perception of the main components that GMac should have. I also was almost finished with two of GMac&#8217;s core components: GMacDSL and the GMacCompiler front-end that translated GMacDSL code into the high-level GMacAST intermediate structure. It was about time to create a proper, but simple, <strong><a href="https://en.wikipedia.org/wiki/Integrated_development_environment" target="_blank" rel="noopener">Integrated Development Environment</a> (IDE)</strong>; the <strong><a href="https://gmac-guides.netlify.com/index.php/gmac-system-guide/" target="_blank" rel="noopener">GMacIDE</a></strong>.</p>
<p>The first thing I needed is a simple colored TextBox control for <a href="https://en.wikipedia.org/wiki/Syntax_highlighting" target="_blank" rel="noopener">Syntax Highlighting</a>. I soon found the nice <a href="https://www.codeproject.com/Articles/161871/Fast-Colored-TextBox-for-syntax-highlighting" target="_blank" rel="noopener">FastColoredTextBox control</a> by Pavel Torgashov <sup class='endnote'><a href='#en-2531-5' id='enref-2531-5' onclick='return hhEndnotes_show(2531)'>5</a></sup>. I implemented a simple interface for GMacDSL code management to handle projects containing multiple code files, to compile and report errors and warnings, explore the GMacAST, generate sample code from a single macro, and perform other functions.</p>
<p>The current GMacIDE is very simple, I hope in the future it can be extended to contain a set of Visual Editors for creating and modifying GMacDSL code and manage the details of code composition from GA-models. In addition, I need to add some form of interactive multivector visualization component to enable exploring GA-based geometry visually.</p>
<h3>Scripting Your Next Play</h3>
<blockquote><p>Talk is cheap. Show me the code. &#8212; Linus Torvalds.</p></blockquote>
<p><a href="/wp-content/uploads/2017/02/GMac.jpg"><img class="alignright wp-image-2476 size-medium" src="/wp-content/uploads/2017/02/GMac-300x169.jpg" alt="Script" width="300" height="169" srcset="/wp-content/uploads/2017/02/GMac-300x169.jpg 300w, /wp-content/uploads/2017/02/GMac-768x432.jpg 768w, /wp-content/uploads/2017/02/GMac-1024x576.jpg 1024w, /wp-content/uploads/2017/02/GMac.jpg 1173w" sizes="(max-width: 300px) 100vw, 300px" /></a>The GMacIDE enables the GMac user to perform many functions. One of the most important of these functions is interfacing with the <strong><a href="https://gmac-guides.netlify.com/index.php/gmac-scripting-guide/" target="_blank" rel="noopener">GMac Scripting Engine</a></strong>. Implementing a scripting engine for a system like GMac is essential. GMacDSL is not Turing-complete, the user can describe GA-based models but can&#8217;t properly interact with them unless he uses more programming structure like loops, conditional execution, expression evaluation, etc. These functions require an interpreter, at least, to be implemented properly. In addition, the powerful symbolic processing capabilities supporting GMac can be accessed using such scripting engine.</p>
<p>GMac scripting is intended for exploration of geometric ideas through GA-based geometric models and algorithms. Three languages can be integrated into a single GMac script, each for a specific purpose:</p>
<ol>
<li><a href="https://en.wikipedia.org/wiki/C_Sharp_(programming_language)" target="_blank" rel="noopener">C# code</a> comprises the main body of the script. C# is not originally designed for <a href="https://en.wikipedia.org/wiki/Scripting_language" target="_blank" rel="noopener">scripting purposes</a>, nevertheless, C# is a <a href="http://csharpindepth.com/" target="_blank" rel="noopener">very powerful</a> compiled statically typed object-oriented language that can be used for scripting. To simplify using C# as a scripting interface for GMac some <a href="https://en.wikipedia.org/wiki/Syntactic_sugar" target="_blank" rel="noopener">syntactic sugar</a> is used to &#8220;sweeten&#8221; the process of reading and writing GMac scripts.</li>
<li><a href="https://gmac-guides.netlify.com/index.php/gmacdsl-guide/" target="_blank" rel="noopener">GMacDSL code</a> can be executed on <a href="https://gmac-guides.netlify.com/index.php/gmacdsl-guide/#frames" target="_blank" rel="noopener">multivector</a> values and user-defined <a href="https://gmac-guides.netlify.com/index.php/gmacdsl-guide/#structures" target="_blank" rel="noopener">structures</a>. The scalar coefficients of multivectors can be numerical, symbolic, or a mix of both. GMac code is passed, as C# public method calls, to GMac internal services in string form to be automatically compiled and executed by the GMacCompiler.</li>
<li><a href="https://en.wikipedia.org/wiki/Mathematica" target="_blank" rel="noopener">Mathematica code</a> can be executed on the Mathematica kernel used in the background by GMac. The Mathematica text code is passed through C# service method calls to the Mathematica kernel through the SymbolicInterface classes. This can be used to exploit the full power of Mathematica through GMac to perform many symbolic manipulations and graphing tasks related to the purpose of the GA-based script exploration.</li>
</ol>
<p>The main input to the script is always a GMacAST structure compiled from the main GMacDSL code. This combination of GMacAST structure, C#, GMac, and Mathematica code, make GMac scripting a very powerful method for GA-models exploration from the simple to the complex.</p>
<p>Scripting in GMac is not intended for efficient execution of GA-based algorithms. If the user is satisfied by the final algorithm, GMacAPI can be used by a good software designer to implement an efficient, well-structured version of the script in any desired programming language, with specific types of multivectors and GA algorithms.</p>
<h3>Composing Text Art</h3>
<blockquote><p>In science, if you don&#8217;t do it, somebody else will. Whereas in art, if Beethoven didn&#8217;t compose the &#8216;Ninth Symphony,&#8217; no one else before or after is going to compose the &#8216;Ninth Symphony&#8217; that he composed; no one else is going to paint &#8216;Starry Night&#8217; by van Gogh. &#8212; Neil deGrasse Tyson.</p></blockquote>
<p><a href="/wp-content/uploads/2017/02/Composing-Code.jpg"><img class="alignright size-medium wp-image-2586" src="/wp-content/uploads/2017/02/Composing-Code-300x200.jpg" alt="Composing Code" width="300" height="200" srcset="/wp-content/uploads/2017/02/Composing-Code-300x200.jpg 300w, /wp-content/uploads/2017/02/Composing-Code.jpg 640w" sizes="(max-width: 300px) 100vw, 300px" /></a>The final stage in any compiler is <a href="https://en.wikipedia.org/wiki/Code_generation_(compiler)" target="_blank" rel="noopener">code generation</a> from some intermediate representation of the input source code. This stage is the most demanding for creativity because it relies on designing and implementing many optimizations to generate target code suitable for its specific consumer. Traditional compilers typically generate machine code for native hardware or byte code for virtual machine frameworks. This form of code is machine-oriented, cold and repetitive code not intended for reading or understanding by humans. GMac, being a DSL based <a href="https://en.wikipedia.org/wiki/Source-to-source_compiler" target="_blank" rel="noopener">source-to-source compiler</a>, produces programmer-oriented textual source code in some high-level human-readable language. The difference between designing the code generator of any typical compiler vs. the code generator of a system like GMac is similar to the difference between designing a machine that creates mechanical parts and designing a tool-set for an artist.</p>
<p>If we look up the verb <em><strong>compose</strong></em> in the <a href="https://www.merriam-webster.com/dictionary/compose" target="_blank" rel="noopener">Merriam-Webster online dictionary</a> we&#8217;ll find the following meanings:</p>
<ol>
<li><strong>A) to form by putting together</strong>: fashion; &#8216;a committee composed of three representatives&#8217;<br />
<strong>B) to form the substance of</strong>: constitute; &#8216;composed of many ingredients&#8217;<br />
<strong>C) to produce (as columns or pages of type) by composition</strong></li>
<li><strong>A) to create by mental or artistic labor</strong>: produce; &#8216;compose a sonnet&#8217;<br />
<strong>B) to formulate and write (a piece of music)</strong>: to compose music for</li>
<li><strong>to deal with or act on so as to reduce to a minimum</strong> &#8216;compose their differences&#8217;</li>
<li><strong>to arrange in proper or orderly form</strong></li>
<li><strong>to free from agitation</strong>: calm, settle &#8216;composed himself&#8217;</li>
</ol>
<p>My personal view of coding is a form of:</p>
<blockquote><p>Creative composition of highly structured, human-understandable, and machine-compilable text holding all the meanings of the verb <em><strong>compose</strong></em> stated above.</p></blockquote>
<p>To me writing code is not just about execution efficiency or blind implementation of algorithms; writing code is fundamentally artistic such that no two skilled software developers may produce the same code for a single problem. Like there can be no machine that may creatively produce music or paintings, there can be no single code generator that can, by itself, write human-understandable code with all its rich content of information, creativity, and beauty. Nevertheless, we can certainly make many smaller tool sets to help the skilled code developer layout code in the way humanly and creatively desired, while automatically generating machine-oriented code from the intermediate representation to free the <em><strong>coding artist</strong></em> from its repetitive cold nature.</p>
<p>The text generation tool set specifically created for GMac, but independently usable otherwise, is a C# library called <a href="https://gmac-guides.netlify.com/index.php/textcomposerlib-guide/" target="_blank" rel="noopener"><strong>TextComposerLib</strong></a>. I made the decision of creating my own text generation component in 2013 after an extensive search for many similar libraries. I found no libraries that satisfied my vision for GMac. The TextComposerLib library is like a set of paint brushes to artists. The user can combine several of its text composition tools to create highly structured text. The structure can be generated on the internal level of a single document, or on the external level of files and folders.</p>
<p>In the future, I hope to make TextComposerLib more versatile and reliable by introducing <a href="https://en.wikipedia.org/wiki/Multithreading_(software)" target="_blank" rel="noopener">Multithreading</a> capabilities and designing a <a href="https://en.wikipedia.org/wiki/Service-oriented_programming" target="_blank" rel="noopener">Service-Oriented</a> interface. I also hope to release it as an open-source component for general text composition tasks.</p>
<h3>Building A Factory</h3>
<blockquote><p>Make everything as simple as possible, but not simpler. &#8212; Albert Einstein.</p></blockquote>
<p><a href="/wp-content/uploads/2017/02/Industrial-robots.jpg"><img class="alignright size-medium wp-image-2528" src="/wp-content/uploads/2017/02/Industrial-robots-300x169.jpg" alt="Factory" width="300" height="169" srcset="/wp-content/uploads/2017/02/Industrial-robots-300x169.jpg 300w, /wp-content/uploads/2017/02/Industrial-robots.jpg 500w" sizes="(max-width: 300px) 100vw, 300px" /></a>In 2014 I began implementing the GMac part I enjoyed the most; the <strong><a href="https://gmac-guides.netlify.com/index.php/gmacapi-guide/" target="_blank" rel="noopener">GMacAPI</a> </strong>code assembly component. If TextComposerLib is like a set of tools for artists to compose with, then GMacAPI is like a fully configurable production line for assembling structured code. Using this extensive and sophisticated <strong><a href="https://en.wikipedia.org/wiki/Application_programming_interface" target="_blank" rel="noopener">Application Programming Interface</a> (API)</strong>, you can perform a full process of assembling code libraries in any desired target programming language. Using the GMacAPI you can:</p>
<ul>
<li>Supply raw materials to the assembly line; mainly a compiled GMacAST data structure that is independent of any particular target language, like C#, Python, C++, Java, etc., from any particular external computing libraries, and from any particular software architecture required.</li>
<li>Use the full composition capabilities of TextComposerLib for producing the final code.</li>
<li>Define sub-processes for assembling subsets of the final code library by inheriting from the GMacAPI core classes.</li>
<li>Monitor and log each step of the code assembly process for debugging and maintenance.</li>
<li>Use GMacDSL macros to produce a series of optimized computationally equivalent low-level code in the target language of choice.</li>
</ul>
<p>I&#8217;m very proud of my work in the GMacAPI as it contains many interesting techniques from computer science and software engineering; especially techniques related to <a href="https://en.wikipedia.org/wiki/Optimizing_compiler" target="_blank" rel="noopener">code block optimization</a>. The tasks in which GMacAPI can be used are diverse and wide-ranging. I&#8217;ve tried my best to make it as simple as possible for a good software Engineer to use a given GA-model and create a full code library out of it. Because such goal is not easy to reach, using the GMacAPI component requires a good deal of learning and experimentation. I hope in the future to make it more accessible through some form of Visual Interface in which the software engineer can lay out the components, connect, and configure them visually with few lines of code as possible.</p>
<h3>Seeking Guidance</h3>
<blockquote><p>Conceptual integrity is the most important consideration in system design. &#8212; Fred Brooks, &#8220;The Mythical Man-Month&#8221;</p></blockquote>
<p><a href="/wp-content/uploads/2017/02/books-659690_640.jpg"><img class="alignright size-medium wp-image-2519" src="/wp-content/uploads/2017/02/books-659690_640-300x200.jpg" alt="Documentation" width="300" height="200" srcset="/wp-content/uploads/2017/02/books-659690_640-300x200.jpg 300w, /wp-content/uploads/2017/02/books-659690_640.jpg 640w" sizes="(max-width: 300px) 100vw, 300px" /></a>Software documentation is a hard but necessary part of any software system. GMac is a sophisticated system with lots of interacting components. For a good part of 2015 and 2016, I concentrated on writing the online <strong><a href="https://gmac-guides.netlify.com/index.php/about-gmac/" target="_blank" rel="noopener">GMac Guides</a></strong>. The GMac Guides explain in good details the structure of the main components of GMac and how to use them as intended. While writing these guides I discovered some design deficiencies in some parts of GMac that needed fixing or enhancing. This is simply because I couldn&#8217;t explain them to myself in plain English, or with a direct example when I tried to write the GMac Guides.</p>
<p>Naturally, the full power of GMac can only be illustrated through practical examples. I&#8217;ve created the <strong><a href="https://gmac-guides.netlify.com/index.php/gmac-samples/" target="_blank" rel="noopener">GMac Samples</a></strong> page on this website for this purpose. In time this page should contain enough examples that I hope would motivate users to explore the computational space using Geometric Algebra and GMac.</p>
<h3>The Next Generation</h3>
<blockquote><p>Space: the final frontier. These are the voyages of the starship Enterprise. Its continuing mission: to explore strange new worlds, to seek out new life and new civilizations, to boldly go where no one has gone before. &#8212; <a href="https://www.youtube.com/watch?v=HnDtvZXYHgE" target="_blank" rel="noopener">Captain Jean-Luc Picard, Star Trek: The Next Generation</a></p></blockquote>
<div id="attachment_2497" style="width: 949px" class="wp-caption aligncenter"><a href="/wp-content/uploads/2017/02/GMac-Components.png"><img class="wp-image-2497 size-full" src="/wp-content/uploads/2017/02/GMac-Components.png" alt="GMac Components" width="939" height="440" srcset="/wp-content/uploads/2017/02/GMac-Components.png 939w, /wp-content/uploads/2017/02/GMac-Components-300x141.png 300w, /wp-content/uploads/2017/02/GMac-Components-768x360.png 768w, /wp-content/uploads/2017/02/GMac-Components-520x245.png 520w" sizes="(max-width: 939px) 100vw, 939px" /></a><p class="wp-caption-text">The main components of GMac</p></div>
<p>I&#8217;m writing these words on the 9th of February 2017; it is my 40th birthday. This post is my final thoughts on the 8 years journey creating my own vessel for exploration, GMac. I don&#8217;t know if I will actually get to use it, as I hope, to explore the computational universe. I still need to add a visualization component and a multivector differentiation component to the mix. I also hope I could modify the design to use other CAS like SymPy or Maple and add a Visual Interface to create GMacDSL code that should be developed to apply functional programming techniques. Many other enhancements and components are possible. Nevertheless, I have learned a lot as I initially expected. I&#8217;m now ready to explore applications and algorithms with my own tool. I&#8217;m ready to contact other people to exchange ideas and investigate possibilities. I&#8217;m ready to begin a new journey as this one ends.</p>
<p><img class="alignright wp-image-2554 size-full" src="/wp-content/uploads/2017/02/Done.png" width="375" height="40" srcset="/wp-content/uploads/2017/02/Done.png 375w, /wp-content/uploads/2017/02/Done-300x32.png 300w" sizes="(max-width: 375px) 100vw, 375px" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<div class='endnotes' id='hhendnotes-2531'>
<ol>
<li id='en-2531-1'>Terence Parr is the creator of <a href="http://www.antlr.org/" target="_blank" rel="noopener"><strong>ANTLR</strong></a> <strong>(AN</strong>other<strong> T</strong>ool for<strong> L</strong>anguage<strong> R</strong>ecognition<strong>)</strong>; a powerful parser generator for reading, processing, executing, or translating structured text or binary files. It&#8217;s widely used to build languages, tools, and frameworks. From a grammar, ANTLR generates a parser that can build and walk parse trees. <span class='endnotereverse'><a href='#enref-2531-1'>&#8617;</a></span></li>
<li id='en-2531-2'>For more information about DSLs and alternative approaches, you can read my post &#8220;<a href="/index.php/2015/09/11/ga-computing1/" target="_blank" rel="noopener">Computing: Please, Mind Your Language!</a>&#8220;. <span class='endnotereverse'><a href='#enref-2531-2'>&#8617;</a></span></li>
<li id='en-2531-3'>You can find good Irony tutorials <a href="https://blogs.msdn.microsoft.com/kirillosenkov/2009/10/31/irony/" target="_blank" rel="noopener">here</a> and <a href="https://www.codeproject.com/Articles/22650/Irony-NET-Compiler-Construction-Kit" target="_blank" rel="noopener">here</a>, in addition to the many samples coming with the <a href="https://github.com/Alxandr/Irony" target="_blank" rel="noopener">Irony source code</a>. <span class='endnotereverse'><a href='#enref-2531-3'>&#8617;</a></span></li>
<li id='en-2531-4'>The IronyGrammars class library is not yet documented. I hope I could release it as an open-source project in the future. <span class='endnotereverse'><a href='#enref-2531-4'>&#8617;</a></span></li>
<li id='en-2531-5'>You can find the FCTB source code <a href="https://github.com/PavelTorgashov/FastColoredTextBox" target="_blank" rel="noopener">here</a>. <span class='endnotereverse'><a href='#enref-2531-5'>&#8617;</a></span></li>
</ol>
</div>
<p>The post <a rel="nofollow" href="/index.php/2017/02/10/gmac-tng-2/">GMac: The Next Generation (2 of 2)</a> appeared first on <a rel="nofollow" href="/">Geometric Algebra Explorer</a>.</p>
]]></content:encoded>
			</item>
		<item>
		<title>Computing: Please, Mind Your Language!</title>
		<link>/index.php/2015/09/11/ga-computing1/</link>
		<pubDate>Fri, 11 Sep 2015 14:00:59 +0000</pubDate>
		<dc:creator><![CDATA[Ahmad Eid]]></dc:creator>
				<category><![CDATA[DSL]]></category>
		<category><![CDATA[Computing]]></category>

		<guid isPermaLink="false">http://gacomputing.info/?p=275</guid>
		<description><![CDATA[<p>Computing is done by programming computers, programming requires programming languages, and programming languages come in many forms and flavors. The creative process of software development, in general, is certainly related to language, thought, and imagination. For geometric modeling and geometric processing applications, the correct selection of a programming language is absolutely fundamental.</p>
<p>The post <a rel="nofollow" href="/index.php/2015/09/11/ga-computing1/">Computing: Please, Mind Your Language!</a> appeared first on <a rel="nofollow" href="/">Geometric Algebra Explorer</a>.</p>
]]></description>
				<content:encoded><![CDATA[<div id="attachment_643" style="width: 730px" class="wp-caption aligncenter"><a href="/wp-content/uploads/2015/09/turing_23-big.jpg"><img class="size-large wp-image-643" src="/wp-content/uploads/2015/09/turing_23-big-772x1024.jpg" alt="turing_23-big" width="720" height="955" srcset="/wp-content/uploads/2015/09/turing_23-big-772x1024.jpg 772w, /wp-content/uploads/2015/09/turing_23-big-226x300.jpg 226w, /wp-content/uploads/2015/09/turing_23-big-768x1019.jpg 768w, /wp-content/uploads/2015/09/turing_23-big.jpg 795w" sizes="(max-width: 720px) 100vw, 720px" /></a><p class="wp-caption-text">A family of algorithmic pen plotted drawings, each presented with the binary text for a Universal Turing Machine (UTM), were created for an exhibition in Manchester on the occasion of the Ninth International Symposium on Electronic Art (1998). (<a href="http://digitalartmuseum.org/verostko/turing_23l.html">Source</a>)</p></div>
<blockquote><p>Language is a process of free creation; its laws and principles are fixed, but the manner in which the principles of generation are used is free and infinitely varied. Even the interpretation and use of words involves a process of free creation. &#8212; Noam Chomsky.</p></blockquote>
<h3>A Computational Universe</h3>
<div id="attachment_672" style="width: 310px" class="wp-caption alignright"><a href="/wp-content/uploads/2015/09/neuron-galaxy_comparison_231214.jpg"><img class="size-medium wp-image-672" src="/wp-content/uploads/2015/09/neuron-galaxy_comparison_231214-300x206.jpg" alt="neuron-galaxy_comparison_231214" width="300" height="206" srcset="/wp-content/uploads/2015/09/neuron-galaxy_comparison_231214-300x206.jpg 300w, /wp-content/uploads/2015/09/neuron-galaxy_comparison_231214-768x527.jpg 768w, /wp-content/uploads/2015/09/neuron-galaxy_comparison_231214-1024x703.jpg 1024w, /wp-content/uploads/2015/09/neuron-galaxy_comparison_231214.jpg 1068w" sizes="(max-width: 300px) 100vw, 300px" /></a><p class="wp-caption-text">One way to understand our computational Universe. Both the brain and the Universe are huge networks that can process information</p></div>
<p>The brilliant German civil engineer <a href="https://en.wikipedia.org/wiki/Konrad_Zuse">Konrad Zuse</a> made a great practical achievement; his functional program-controlled Turing-complete Z3 became operational in May 1941. But his most brilliant conceptual achievement was in 1967 when Zuse suggested that the universe itself is running on a cellular automaton or similar computational structure; what we know now as <a href="https://en.wikipedia.org/wiki/Digital_physics">digital physics</a>. In 1969, he published the book &#8220;Calculating Space&#8221; challenging the long-held view that some physical laws are continuous by nature<sup class='endnote'><a href='#en-275-1' id='enref-275-1' onclick='return hhEndnotes_show(275)'>1</a></sup>. This idea has attracted a lot of attention, since there is no physical evidence against Zuse&#8217;s thesis, but practically isolated Zuse from the scientific community for a very long time. Later on, in their attempt to unify relativity with quantum mechanics, many physicists are realizing that information is more fundamental than space and time; that space-time might be emergent from information exchange and processing in our discrete computational universe.</p>
<div id="attachment_693" style="width: 310px" class="wp-caption alignleft"><a href="/wp-content/uploads/2015/09/maxresdefault.jpg"><img class="size-medium wp-image-693" src="/wp-content/uploads/2015/09/maxresdefault-300x169.jpg" alt="maxresdefault" width="300" height="169" srcset="/wp-content/uploads/2015/09/maxresdefault-300x169.jpg 300w, /wp-content/uploads/2015/09/maxresdefault-768x432.jpg 768w, /wp-content/uploads/2015/09/maxresdefault-1024x576.jpg 1024w, /wp-content/uploads/2015/09/maxresdefault.jpg 1280w" sizes="(max-width: 300px) 100vw, 300px" /></a><p class="wp-caption-text">Cellular and DNA biochemical reactions are computational in nature. See <a href="https://www.dnalc.org/resources/3d/">here</a> and <a href="https://www.youtube.com/watch?v=2KoLnIwoZKU&amp;list=PLD0D5F297744AD515">here</a> for more details</p></div>
<p>Information processing and computations are found everywhere in the natural world; inspiring us with many new computational paradigms every day. Information processing is found on the level of <a href="https://en.wikipedia.org/wiki/Quantum_information_science">quantum mechanics</a> and how elementary particles behave, in the miraculous way of <a href="https://en.wikipedia.org/wiki/DNA_computing">manufacturing protein from DNA</a>, in the way <a href="https://en.wikipedia.org/wiki/Swarm_intelligence">swarms of insects optimize</a> their search for food, and much more.</p>
<p>Information means distinctions between things. When we create abstractions we choose to ignore information about many distinct concrete objects in order to conceptually unify them into one abstraction. The level of abstraction depends on what information we decide to ignore and what we decide to keep. In physics, we need to investigate constraints and initial conditions, in the form of measurements, on the studied physical system by performing experiments as part of the information framework we deal with to arrive at accurate models. In computer science, we do not require any specific constraints or initial conditions in general; unless we are creating accurate physical simulations. We are much more free to investigate any computational universe we can imagine possible, as long as it can be computed in reasonable time-space constraints. The key concepts here are: computational ideas and programming languages.</p>
<h3>Language, Thought, and Imagination</h3>
<div id="attachment_662" style="width: 310px" class="wp-caption alignright"><a href="/wp-content/uploads/2015/09/baby.computer.confused.site_.sized_.png"><img class="size-medium wp-image-662" src="/wp-content/uploads/2015/09/baby.computer.confused.site_.sized_-300x195.png" alt="baby.computer.confused.site_.sized_" width="300" height="195" srcset="/wp-content/uploads/2015/09/baby.computer.confused.site_.sized_-300x195.png 300w, /wp-content/uploads/2015/09/baby.computer.confused.site_.sized_-768x500.png 768w, /wp-content/uploads/2015/09/baby.computer.confused.site_.sized_.png 859w" sizes="(max-width: 300px) 100vw, 300px" /></a><p class="wp-caption-text">There are deep mutual influences between language and ideas (<a href="https://curatti.com/9-things-data-big-small/">Source</a>)</p></div>
<p>Computing is done by programming computers, programming requires programming languages, and programming languages come in many forms and flavors. The creative process of software development, in general, is certainly related to language, thought, and imagination. For geometric modeling and geometric processing applications, the correct selection of a programming language is absolutely fundamental.</p>
<p>In the realm of philosophy of language, the &#8220;<a href="https://thephilosophyforum.com/discussion/90/ideational-theories-of-meaning/p1">ideational theory of meaning</a>&#8220;, originally developed by <a href="https://en.wikipedia.org/wiki/John_Locke">John Locke</a> in the 17th century, has 3 fundamental theses:</p>
<ol>
<li>That the primary end of language is the communication of thought.</li>
<li>That thinking at its most basic consists in &#8216;having ideas&#8217;; that is, thinking is fundamentally imaginative in nature.</li>
<li>That words acquire their power to express thoughts by being made, through custom and convention, to represent or signify &#8220;ideas&#8221; in the minds of those who use them.</li>
</ol>
<p>On some or many occasions we may &#8220;think in words&#8221;, but there is a fundamental level of thought at which it is not linguistic but imaginative in nature: a level at which we &#8220;think in ideas&#8221;. Speaking loosely, it might almost be said that imagination is a kind of surrogate perception; that to exercise one&#8217;s imagination is to rehearse or anticipate actually or possible episodes of perceptual experience, though with a degree of voluntary control that is characteristically absent from perception itself; in perception one can direct one&#8217;s attention at will, but has very little voluntary control over what is perceived once one&#8217;s attention has been fixed. Imagination, like perception, may be classified by reference to its sensory modes and thus we have visual, auditory and tactile imagination, just as we have these forms of perception. Unsurprisingly, there is neuropsychological and neurophysiological evidence that many of the same areas of the cortex are typically engaged in imagination as in perception. These observations may suffice to highlight the intimacy of the relation between the two<sup class='endnote'><a href='#en-275-2' id='enref-275-2' onclick='return hhEndnotes_show(275)'>2</a></sup>.</p>
<p>The way language can affect our thought process is not simple; there is always a two-way mutual influence between language and idea. <a href="https://www.linguisticsociety.org/content/does-language-i-speak-influence-way-i-think">Some say</a> that our language doesn&#8217;t force us to see only what it gives us words for, but it can affect how we put things into groups<sup class='endnote'><a href='#en-275-3' id='enref-275-3' onclick='return hhEndnotes_show(275)'>3</a></sup>. We learn to group things that are similar and give them the same label, but what counts as being similar enough to fall under a single label may vary from language to language. In other words, the influence of language isn&#8217;t so much on what we can think about, or even what we do think about, but rather on how we break up reality into categories and label them. And in this, our language and our thoughts are probably both greatly influenced by our culture. <a href="https://www.philosophytalk.org/blog/does-language-affect-thought">Others say</a> the language we speak broadly affects or even determines the way we experience the world, from the way we perceive it, to the way to categorize it, to the way we cognize it. There are definite differences in perception between people speaking different languages. Studies have shown that changing how people talk changes how they think. Research has been uncovering how language shapes even the most fundamental dimensions of human experience: space, time, causality and relationships to others<sup class='endnote'><a href='#en-275-4' id='enref-275-4' onclick='return hhEndnotes_show(275)'>4</a></sup>.</p>
<p><a href="/wp-content/uploads/2015/09/codeeval2014.png"><img class="alignleft size-medium wp-image-692" src="/wp-content/uploads/2015/09/codeeval2014-300x225.png" alt="codeeval2014" width="300" height="225" srcset="/wp-content/uploads/2015/09/codeeval2014-300x225.png 300w, /wp-content/uploads/2015/09/codeeval2014-768x576.png 768w, /wp-content/uploads/2015/09/codeeval2014.png 1000w" sizes="(max-width: 300px) 100vw, 300px" /></a>Computer languages are human in their expressive nature, but computational in their intended function. This dual aspect of programming languages is, in my opinion, the main reason behind the rise and fall of many programming languages and code-development paradigms. No one today uses Assembly for developing complex software systems; while having a huge (theoretical) computational power, the &#8220;human side&#8221; of Assembly (readability, writability, maintainability, testability, etc.) is almost non-existent. Applying the ideational theory of meaning to computing, our ultimate goal is to create a computer that can directly understand our internal thoughts and ideas about what we need to compute; which is currently just a great plot for a science fiction story and no more. The next best thing is to create computational languages that we can express our ideas in the least effort and largest correspondence possible. Our general purpose programming languages, especially the object-oriented ones, go a long way to that goal, but we certainly can, and need, to do much more to get closer to &#8220;computing with ideas&#8221; rather than turning ourselves into imagination-free bio-computers.</p>
<h3>Our Many Tongues</h3>
<div id="attachment_685" style="width: 310px" class="wp-caption alignright"><a href="/wp-content/uploads/2015/09/paradigmsDIAGRAMeng108_02.png"><img class="size-medium wp-image-685" src="/wp-content/uploads/2015/09/paradigmsDIAGRAMeng108_02-300x159.png" alt="paradigmsDIAGRAMeng108_02" width="300" height="159" srcset="/wp-content/uploads/2015/09/paradigmsDIAGRAMeng108_02-300x159.png 300w, /wp-content/uploads/2015/09/paradigmsDIAGRAMeng108_02-768x408.png 768w, /wp-content/uploads/2015/09/paradigmsDIAGRAMeng108_02-1024x544.png 1024w" sizes="(max-width: 300px) 100vw, 300px" /></a><p class="wp-caption-text">A classification of the principal programming paradigms (<a href="https://www.info.ucl.ac.be/~pvr/paradigms.html">Source</a>)</p></div>
<p>As a software developer, I realized early in my programming life that not all languages are created equal. It&#8217;s not just that different languages have different features, but the existence of profoundly distinct ways of thinking; we call them <a href="https://en.wikipedia.org/wiki/Comparison_of_multi-paradigm_programming_languages">Programming Paradigms</a>. Often to create a complex software system we need to use more than one paradigm for different parts of the system. As stated in an IEEE Software issue on multiparadigm programming<sup class='endnote'><a href='#en-275-5' id='enref-275-5' onclick='return hhEndnotes_show(275)'>5</a></sup>:</p>
<blockquote><p>But today’s applications are seldom homogeneous. They are frequently complex systems, made up of many subcomponents that require a mixture of technologies. Thus, using just one language technology and paradigm is becoming much less common, replaced by multiparadigm programming in which the heterogeneous application consists of several subcomponents, each implemented with an appropriate paradigm and able to communicate with other subcomponents implemented with a different paradigm. When more than one language is used, we call this polyglot (“many tongues”) programming.</p>
<p>Internet and intranet applications are inherently heterogeneous, often combining languages like JavaScript, Flash, and HTML in the user interface (UI), Java, C#, and Ruby in the middle tier, and SQL in the database. Not only are many languages involved, but there are also many paradigms, with SQL implementing the relational model, and object-oriented programming (OOP) dominating the middle and UI tiers. Even some “single-tier” desktop and server applications mix implementation languages, such as a fast, compiled “kernel” language for performance-sensitive components and a scripting language for integrating those components to create features, make extensibility easier, and so on.</p></blockquote>
<div id="attachment_702" style="width: 310px" class="wp-caption alignleft"><a href="/wp-content/uploads/2015/09/expressiveness_by_iqr_weighted2.png"><img class="wp-image-702" src="/wp-content/uploads/2015/09/expressiveness_by_iqr_weighted2.png" alt="expressiveness_by_iqr_weighted2" width="300" height="104" srcset="/wp-content/uploads/2015/09/expressiveness_by_iqr_weighted2.png 1366w, /wp-content/uploads/2015/09/expressiveness_by_iqr_weighted2-300x104.png 300w, /wp-content/uploads/2015/09/expressiveness_by_iqr_weighted2-768x266.png 768w, /wp-content/uploads/2015/09/expressiveness_by_iqr_weighted2-1024x355.png 1024w" sizes="(max-width: 300px) 100vw, 300px" /></a><p class="wp-caption-text">Programming languages ranked by expressiveness (<a href="http://redmonk.com/dberkholz/2013/03/25/programming-languages-ranked-by-expressiveness/">Source</a>)</p></div>
<p>Personally, I&#8217;ve been using several paradigms in my software. I started out using procedural (imperative) programming with VB and C, then I discovered object oriented programming with C++, VB.NET, and C#, followed by relational SQL programming, some logic programming with Prolog in the AI course I teach, and finally some functional programming in F#. Each paradigm required a basically different way of thinking and expressing (coding). The controversy between language philosophers about how language affects ideas is settled for me; with each programming paradigm my way of thinking about computation is indeed changed considerably. Apart from the technical advantage of integrating several paradigms, for a software engineer, it&#8217;s necessary to think and code in several paradigms to reach a good understanding of the concept computation in general. You may have a preferred paradigm in which you can think clearly and fluently, but only by learning other programming paradigms you would appreciate the universal generality and relevance of information and computing to our life in every aspect. This multi-paradigm insight also inspires very good ideas about explorations to the Computational Universe, the physical and the non-physical. The presence of so much programming paradigms strongly indicates the many dimensions of computing. Each computational field in physics, biology, engineering, and science will have its own method of thinking and &#8220;space of computational imagination&#8221;; rightfully requiring its own domain-specific language for expressing such ideas. Now the ability to compute is not just for computer scientists and software engineers, it should be a right for every researcher\practitioner in all fields of science; this is not the current state of matters as one might think.</p>
<h3>Getting Lost in a Public Library</h3>
<blockquote><p>Before software can be reusable it first has to be usable. &#8212; Ralph Johnson.</p></blockquote>
<div id="attachment_708" style="width: 310px" class="wp-caption alignright"><a href="/wp-content/uploads/2015/09/OGLCS.jpg"><img class="size-medium wp-image-708" src="/wp-content/uploads/2015/09/OGLCS-300x169.jpg" alt="OGLCS" width="300" height="169" srcset="/wp-content/uploads/2015/09/OGLCS-300x169.jpg 300w, /wp-content/uploads/2015/09/OGLCS-768x432.jpg 768w, /wp-content/uploads/2015/09/OGLCS-1024x576.jpg 1024w, /wp-content/uploads/2015/09/OGLCS.jpg 1500w" sizes="(max-width: 300px) 100vw, 300px" /></a><p class="wp-caption-text">Software libraries tend to grow complex rapidly; reducing the ability of non software-specialists to learn and use them efficiently in reasonable time. (<a href="https://www.anandtech.com/show/6134/khronos-announces-opengl-es-30-opengl-43-astc-texture-compression-clu/3">Source</a>)</p></div>
<p>General purpose programming languages (GPLs) are great tools, we think they can be used to create any possible computation; but can they really be so? Assembly can also be used for general purpose programming, but very few use it nowadays. GPLs provide general computational abstractions easing the creation of software; abstractions like subroutines, classes, objects, numerical variables, iteration, and conditional branching. These are similar to well organized &#8220;building standards&#8221; for adding water pipes and electrical wiring inside buildings. These abstractions are not intended, or even well understood for that matter, for end users; they are made by software people to be used by software people. The problem any scientist face in order to exercise his &#8220;right to compute&#8221; is that he has to spend a considerable time learning a complex low-level language like C++ to guarantee the efficiency of his computations and integration with other &#8220;reusable&#8221; software libraries. Now practitioners and researchers that are not software engineers have a limited set of options to practice their right for digital computation<sup class='endnote'><a href='#en-275-6' id='enref-275-6' onclick='return hhEndnotes_show(275)'>6</a></sup>:</p>
<ol>
<li>Take the difficult road to learning a GPL, while studying their original fields, and create private libraries for their domain based on their own methods of thinking; facing software horrors like memory management, numerical error control, and bug tracking on their own.</li>
<li>Come together and create super large libraries, with thousands or millions of lines of code, for their collective domain specific ideas. Then any newcomer to their field will have to learn not only the abstract concepts and practical techniques of their domain of knowledge but also the intricate behavior of the library in addition to the hosting GPL; things like general library and specific algorithm initialization, external I\O data types for data exchange, error reporting behavior, data reporting methods, and many more.</li>
<li>Use the programming skills of software engineers, that are not aware of their specific abstractions and domain of knowledge, to develop software systems usable through graphical user interfaces that may never cover all aspects of the computational tasks at hand, also requiring considerable learning efforts, and perhaps provide some API for integration with other libraries.</li>
</ol>
<p>Software libraries created with GPLs are inevitable, but their direct use by non-software specialists is not. Others have written excellent fast libraries that perform complex computational tasks for us. Like one interacts with the water pipes and electrical wiring at home through elegant simple to use interfaces, we must hide our libraries behind the simple to use interfaces; with abstractions relevant to our domains of abstractions not to general computing abstractions. Two approaches are used for such simpler programmable interfaces. The first is an architecture referred to as &#8220;components + scripts = applications&#8221;. It’s a &#8220;best of both worlds&#8221; solution, flexible and extensible, yet still providing high performance where necessary. The second is by using Domain Specific Languages (DSLs) that enable end-user programming in the most relevant and expressive way to his domain of ideas.</p>
<h3>Joys of The Pythonistas</h3>
<div id="attachment_712" style="width: 310px" class="wp-caption alignright"><a href="/wp-content/uploads/2015/09/5-Best-Python-Libraries-For-Data-Science.png"><img class="size-medium wp-image-712" src="/wp-content/uploads/2015/09/5-Best-Python-Libraries-For-Data-Science-300x155.png" alt="5-Best-Python-Libraries-For-Data-Science" width="300" height="155" srcset="/wp-content/uploads/2015/09/5-Best-Python-Libraries-For-Data-Science-300x155.png 300w, /wp-content/uploads/2015/09/5-Best-Python-Libraries-For-Data-Science-768x398.png 768w, /wp-content/uploads/2015/09/5-Best-Python-Libraries-For-Data-Science.png 1000w" sizes="(max-width: 300px) 100vw, 300px" /></a><p class="wp-caption-text">Python is the most successful programming language for dealing with the libraries problem (<a href="https://datafloq.com/read/5-best-python-libraries-for-data-science/994">Source</a>)</p></div>
<p>Compared to computer scientists and software engineers, many scientists and engineers practice programming for half or more of their work time, they are usually self-taught programmers with not enough background or training in computer science. They tend to use inefficient programming practices, and often select the wrong programming languages for the task at hand. They usually try doing everything using a single GPL (C++, Fortran, C#, Java, &#8230;) that they invest large amounts of time trying to study. Scientific programming needs rapid prototyping (to explore the largest number of ideas in the smallest time possible), efficiency for computational kernels, the use of pre-written libraries and packages (for vectors, matrices, modeling, simulation, visualization, etc.), and extensibility through, for example, web front-ends and database back-ends. One solution that found great acceptance among these hard working knowledge seekers is called <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a>. Python is <a href="https://www.python.org/about/success/">very successful</a> among scientists and engineers, among other disciplines. It&#8217;s a strongly but dynamically typed scripting GPL with strong object oriented features. Python&#8217;s main strengths are being intuitive, readable, open source, free, with a large well supported, well documented scientific library. Its design is of a small core language with a large standard library and an easily extensible interpreter.</p>
<div id="attachment_725" style="width: 310px" class="wp-caption alignleft"><a href="/wp-content/uploads/2015/09/ndepend-optimization-graph.png"><img class="size-medium wp-image-725" src="/wp-content/uploads/2015/09/ndepend-optimization-graph-300x120.png" alt="ndepend-optimization-graph" width="300" height="120" srcset="/wp-content/uploads/2015/09/ndepend-optimization-graph-300x120.png 300w, /wp-content/uploads/2015/09/ndepend-optimization-graph.png 600w" sizes="(max-width: 300px) 100vw, 300px" /></a><p class="wp-caption-text">Many code slow-downs are due to bad design not specific language use. (<a href="http://codebetter.com/patricksmacchia/2008/12/01/lessons-learned-from-a-real-world-focus-on-performance/">Source</a>)</p></div>
<p>Many computer folks would say Python is too slow compared to Fortran or C++; generally speaking, they are right. Native Python code may execute 10 times slower than C++ or Fortran. But at the same time, Python code is 10 times faster to write than C++ and Fortran; its compactness may give additional time savings during bug tracking and maintenance. For the world of scientific computation, many slow-downs are due to algorithmic complexity; a researcher friend once told me he made a modification to an algorithm that made it&#8217;s Matlab implementation several times faster than its C++ implementation. The remaining performance-critical code can always be factored out into fast libraries in Fortran or C++ and called directly from the main clear and easy to maintain &#8220;gluing code&#8221; created with Python. The overall economic saving is not a trivial thing; when Fortran was invented computer time was much more expensive than programmer time, in the 1990&#8217;s <a href="https://blog.codinghorror.com/hardware-is-cheap-programmers-are-expensive/">that situation reversed</a> and now many consider ease of programming much important than the cost of hardware for many applications. Not realizing these facts is a serious problem with many computational systems. As <a href="https://en.wikipedia.org/wiki/William_Wulf">William Allan Wulf</a> said:</p>
<blockquote><p>More computing sins are committed in the name of efficiency (without necessarily achieving it) than for any other single reason &#8211; including blind stupidity.</p></blockquote>
<div id="attachment_715" style="width: 310px" class="wp-caption alignright"><a href="/wp-content/uploads/2015/09/numpy.png"><img class="wp-image-715" src="/wp-content/uploads/2015/09/numpy.png" alt="numpy" width="300" height="206" srcset="/wp-content/uploads/2015/09/numpy.png 774w, /wp-content/uploads/2015/09/numpy-300x206.png 300w, /wp-content/uploads/2015/09/numpy-768x528.png 768w" sizes="(max-width: 300px) 100vw, 300px" /></a><p class="wp-caption-text">Python&#8217;s most important library is NumPy, many other libraries are based on it. (<a href="https://www.slideshare.net/pythoncharmers/python-for-science-and-engineering-a-presentation-to-astar-and-the-singapore-computational-sciences-club-edward-schofield-june-2011">Source</a>)</p></div>
<p>Python is good for rapid prototyping, plotting and visualization, numerical computing, web and database programming, and the creation of all-purpose glue code; it&#8217;s ideal for scientific computing investigations. Like Matlab, Python is interpreted with powerful I/O and plotting capabilities; Python is better as a more powerful GPL while being free, open source software, Matlab certainly costs much. Compared to C++, python has a superior scientific oriented standard library while being much easier to learn, write, and maintain; it can still inter-operate with existing C and C++ libraries easily. Like C# and Java, Python is a well-designed language while being much simpler to use. But the static typing capabilities of Java and C# make Python less attractive for many software developers; static typing catches many logical errors at design time. Some of the widely used libraries for Python include <a href="http://www.numpy.org/">NumPy</a>, <a href="https://www.scipy.org/">SciPy</a>, <a href="http://matplotlib.org/">Matplotlib</a>, <a href="http://mayavi.sourceforge.net/">Mayavi</a>, <a href="http://www.sympy.org/en/index.html">SymPy</a> (that includes <a href="http://docs.sympy.org/0.7.3/modules/galgebra/GA.html">a module</a> for symbolic Geometric Algebra),  <a href="http://vpython.org/">VPython</a>, and <a href="http://ipython.org/">IPython</a>. Python has been awarded a TIOBE Programming Language of the Year award twice (in 2007 and 2010), which is given to the language with the greatest growth in popularity over the course of a year, as measured by the <a href="https://www.tiobe.com/tiobe-index//">TIOBE index</a>. The design of Python has <a href="https://en.wikipedia.org/wiki/Python_(programming_language)#Languages_influenced_by_Python">influenced</a> many following programming languages.</p>
<h3>Changing Computational Orientations</h3>
<div id="attachment_628" style="width: 310px" class="wp-caption alignright"><a href="/wp-content/uploads/2015/08/lop.png"><img class="size-medium wp-image-628" src="/wp-content/uploads/2015/08/lop-300x218.png" alt="lop" width="300" height="218" srcset="/wp-content/uploads/2015/08/lop-300x218.png 300w, /wp-content/uploads/2015/08/lop.png 696w" sizes="(max-width: 300px) 100vw, 300px" /></a><p class="wp-caption-text">General Purpose vs Domain-Specific Program Development (<a href="http://www.onboard.jetbrains.com/is1/articles/04/10/lop/mps.pdf">Source</a>)</p></div>
<p>The scripting architecture of Python is great, but it suffers from the same basic abstraction problem as GPLs do. Each scientific and engineering field has its own set of common abstractions. For example, the same linear mathematical models can be used for many systems in electrical, mechanical, fluid, and construction engineering but each field defines its own language, including what ideas to group together and what ideas to ignore, for information exchange and computation. The computational base may be generally the same but the abstraction interface is quite distinct between those fields; this is where Domain Specific Languages shine. DSLs can be used to solve the computational form of the famous &#8220;last mile&#8221; problem in <a href="https://en.wikipedia.org/wiki/Last_mile">communications</a> and <a href="https://en.wikipedia.org/wiki/Last_mile_(transportation)">transportation</a>; where the things to be communicated or transported are computational ideas between domain-compatible recipients.</p>
<div id="attachment_742" style="width: 310px" class="wp-caption alignleft"><a href="/wp-content/uploads/2015/09/gpl-vs-dsl.png"><img class="size-medium wp-image-742" src="/wp-content/uploads/2015/09/gpl-vs-dsl-300x226.png" alt="gpl-vs-dsl" width="300" height="226" srcset="/wp-content/uploads/2015/09/gpl-vs-dsl-300x226.png 300w, /wp-content/uploads/2015/09/gpl-vs-dsl.png 730w" sizes="(max-width: 300px) 100vw, 300px" /></a><p class="wp-caption-text">Features of GPLs and DSLs (<a href="http://www.voelter.de/dslbook/markusvoelter-dslengineering-design-slides-1.0.pdf">Source</a>)</p></div>
<p>When trying to find discriminating definitions for GPLs and DSLs you may get surprised to find more &#8220;statements of impression&#8221; than solid consistent definitions. The distinction between DSLs and GPLs is not sharp but rather gradual<sup class='endnote'><a href='#en-275-7' id='enref-275-7' onclick='return hhEndnotes_show(275)'>7</a></sup>. Many GPLs started out as DSLs and then gained enough popularity to be called general purpose. When searching for features that make a language labeled domain specific, you find the general idea go around DSLs being ad hoc, custom made, non-general, having limited expressiveness, often leading to <a href="https://en.wikipedia.org/wiki/Domain-specific_multimodeling#Coordination_problem">language cacophony</a>, requiring much training, less technically supported, and having a small user base. The reason behind such impressions is the absence of the following points from the minds of many:</p>
<ul>
<li>All computer languages are initially ad hoc. No single language, GPL or DSL, can serve as a general solution for expressing all computational ideas. This fact is manifested in the <a href="https://en.wikipedia.org/wiki/List_of_programming_languages_by_type">many languages</a> out there each having strengths and weaknesses depending on the way of intended use.</li>
<li>Generality is a blurry feature of many computer languages. Any <a href="https://en.wikipedia.org/wiki/Turing_completeness">Turing-complete</a> language can be, theoretically, used as a general purpose programming language. The main reason that GPLs are called general is that many people from many diverse domains use them. The fact is that GPLs are actually based on computer science types of abstractions; they are domain specific where the domain is computer science or one of its sub-domains (a.k.a. programming paradigms). Computer science is, in effect, forcing its abstractions and languages on all other fields for historical reasons.</li>
<li>As Martin Fowler <a href="https://martinfowler.com/bliki/DslQandA.html">states clearly</a>, we already have a cacophony of frameworks that programmers have to learn. That&#8217;s the inevitable consequence of reusable software, which is the only way we can get a handle on all the things software has to do these days. In essence, a DSL is nothing more than a fancy facade over a framework. As a result, they contribute little complexity over what is already there. Indeed a good DSL should make things better by making these frameworks easier to use. The same logic applies to training where training on a DSL is much easier than training on its base library or framework.</li>
<li>Many DSLs are generally much simpler than GPLs specifically because they serve a smaller number of very specialized people. A good architecture should be a well-supported library or framework with a large user base on which we develop several simple DSLs for several domains. The complexity should be mostly in the library while the interface should remain simple; just like the interfaces we use at home for devices and water supplies.</li>
</ul>
<p>The actual difficulty facing DSLs is their design and implementation process; the term <a href="http://www.onboard.jetbrains.com/articles/04/10/lop/">Language Oriented Programming</a> was created for this purpose. Designing a good usable DSL is relatively complex, it&#8217;s not for the average programmer; it requires good experience not just with the domain of the DSL but in computer language design in general. A good DSL designer will conform to some set of general <a href="https://arxiv.org/abs/1409.2378">guidelines</a> that are useful for such task. For a software engineer like me, I found great joys and gained valuable experience, similar to what Walter Bright&#8217;s expressed in <a href="http://www.drdobbs.com/architecture-and-design/so-you-want-to-write-your-own-language/240165488">his article here</a> when designing my first DSL for geometric algebra modeling: GMacDSL. I was originally &#8220;object oriented&#8221; but now I&#8217;m &#8220;language oriented&#8221;. Instead of thinking about complex problems as a set of interacting objects of some classes, I can now imagine the problem as a set of domain entities or components that can be organized using a language for performing the desired computation. Changing one&#8217;s &#8220;computational orientation&#8221; is not an easy process but it is definitely rewarding; instead of thinking in objects or procedures like a computer does, I now think in the language of geometric modeling computations like normal humans often do. As Sergey Demitriev says in <a href="http://www.onboard.jetbrains.com/is1/articles/04/10/lop/mps.pdf">his article</a> &#8220;Language Oriented Programming: The Next Programming Paradigm&#8221;:</p>
<blockquote><p>Today&#8217;s mainstream approach to programming has some crucial built-in assumptions which hold us back like chains around our necks, though most programmers don&#8217;t realize this. With all the progress made so far in programming, we are still in the Stone Age. We&#8217;ve got our trusty stone axe (object-oriented programming), which serves us well, but tends to chip and crack when used against the hardest problems. To advance beyond stone, we must tame fire. Only then can we forge new tools and spark a new age of invention and an explosion of new technologies. I&#8217;m talking about limitations of programming which force the programmer to think like the computer rather than having the computer think more like the programmer.</p></blockquote>
<p><a href="/wp-content/uploads/2015/09/done5.png"><img class="alignright size-medium wp-image-745" src="/wp-content/uploads/2015/09/done5-300x40.png" alt="done5" width="300" height="40" /></a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr />
<h3></h3>
<div class='endnotes' id='hhendnotes-275'>
<ol>
<li id='en-275-1'>In the book &#8220;Science and Ultimate Reality&#8221; about <a href="https://en.wikipedia.org/wiki/John_Archibald_Wheeler">John Archibald Wheeler</a>, it&#8217;s stated that:<br />
<blockquote><p>Some even go so far as to claim that the universe is a gigantic computer. The sociology underlying this line of thinking is interesting. There is a popular conception that science drives technology rather than the other way about, but a study of history suggests a more subtle interplay. There has always been a temptation to use the pinnacle of contemporary technology as a metaphor for nature. In ancient Greece, the ruler and compass, and musical instruments, were the latest technological marvels. The Greeks built an entire world view based on geometry and harmony, from the music of the spheres to the mystical properties associated with certain geometrical shapes. Centuries later, in Renaissance Europe, the clock represented the finest in craftsmanship, and Newton constructed his theory of the clockwork universe by analogy. Then in the nineteenth century the steam engine impressed everybody, and lo and behold, physicists began talking about the universe as a thermodynamic system sliding toward a final heat death. In recent times the digital computer has served as a seductive metaphor for nature. Rather than thinking of the universe as matter in motion, one could regard it as information being processed.</p></blockquote>
<p>Physicists even computed how much information is possible to exist in any volume of space in the universe. See these two lectures for more details: &#8220;<a href="https://www.youtube.com/watch?v=PKkiy24LqBQ">Rebooting The Cosmos: Is the Universe The Ultimate Computer?</a>&#8221; and &#8220;<a href="https://www.youtube.com/watch?v=NsbZT9bJ1s4&amp;feature=iv&amp;src_vid=PKkiy24LqBQ&amp;annotation_id=annotation_3629920323">A Thin Sheet of Reality: The Universe as a Hologram</a>&#8220;. <span class='endnotereverse'><a href='#enref-275-1'>&#8617;</a></span></li>
<li id='en-275-2'>E.J.Lowe, &#8220;Subjects of Experience&#8221;. Cambridge University Press 2006 <span class='endnotereverse'><a href='#enref-275-2'>&#8617;</a></span></li>
<li id='en-275-3'>One of the jobs of a child learning language is to figure out which things are called by the same word. After learning that the family&#8217;s St. Bernard is a dog, the child may see a cow and say dog, thinking that the two things count as the same. Or the child may not realize that the neighbor&#8217;s chihuahua also counts as a dog. The child has to learn what range of objects is covered by the word &#8220;dog&#8221;. <span class='endnotereverse'><a href='#enref-275-3'>&#8617;</a></span></li>
<li id='en-275-4'>Lera Boroditsky, &#8220;<a href="http://www.gwashingtonhs.org/ourpages/auto/2013/10/23/68598699/sci-am-2011.pdf">How Language Shapes Thought</a>&#8220;. Scientific American, February 2011 <span class='endnotereverse'><a href='#enref-275-4'>&#8617;</a></span></li>
<li id='en-275-5'>D. Wampler, T. Clark, &#8220;Guest Editors&#8217; Introduction: Multiparadigm Programming&#8221;. IEEE Software, Issue 5 September/October 2010 <span class='endnotereverse'><a href='#enref-275-5'>&#8617;</a></span></li>
<li id='en-275-6'>Here is one typical example in <a href="https://www.python.org/about/success/astra/">computational chemistry</a> <span class='endnotereverse'><a href='#enref-275-6'>&#8617;</a></span></li>
<li id='en-275-7'>Markus Voelter, &#8220;DSL Engineering: Designing, Implementing and Using Domain-Specific Languages&#8221;. CreateSpace Independent Publishing Platform 2013, <a href="http://dslbook.org/">available online</a> <span class='endnotereverse'><a href='#enref-275-7'>&#8617;</a></span></li>
</ol>
</div>
<p>The post <a rel="nofollow" href="/index.php/2015/09/11/ga-computing1/">Computing: Please, Mind Your Language!</a> appeared first on <a rel="nofollow" href="/">Geometric Algebra Explorer</a>.</p>
]]></content:encoded>
			</item>
	</channel>
</rss>

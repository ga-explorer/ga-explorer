<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Geometric Computing &#8211; Geometric Algebra Explorer</title>
	<atom:link href="/index.php/category/computing/geometric-computing/feed/" rel="self" type="application/rss+xml" />
	<link>/</link>
	<description>Voyaging the Computational Universe with Geometric Algebra</description>
	<lastBuildDate>Fri, 27 Oct 2017 18:55:16 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.8.2</generator>

<image>
	<url>/wp-content/uploads/2016/12/cropped-GAExplorer-Icon-150x150.jpg</url>
	<title>Geometric Computing &#8211; Geometric Algebra Explorer</title>
	<link>/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Computing for Geometry: When the Going Gets Tough &#8230;</title>
		<link>/index.php/2015/09/18/ga-computing2/</link>
		<pubDate>Fri, 18 Sep 2015 14:00:22 +0000</pubDate>
		<dc:creator><![CDATA[Ahmad Eid]]></dc:creator>
				<category><![CDATA[Geometric Computing]]></category>

		<guid isPermaLink="false">http://gacomputing.info/?p=622</guid>
		<description><![CDATA[<p>The power of mathematics is often to change one thing into another, to change geometry into language. &#8211;Marcus du Sautoy. n the previous post we read how our languages and ideas about the computational universe&#46;&#46;&#46;</p>
<p>The post <a rel="nofollow" href="/index.php/2015/09/18/ga-computing2/">Computing for Geometry: When the Going Gets Tough &#8230;</a> appeared first on <a rel="nofollow" href="/">Geometric Algebra Explorer</a>.</p>
]]></description>
				<content:encoded><![CDATA[<div id="attachment_376" style="width: 1010px" class="wp-caption aligncenter"><img class="wp-image-376 size-full" src="/wp-content/uploads/2015/07/bathsheba-grossman-lamp.jpg" alt="bathsheba-grossman-lamp" width="1000" height="1000" srcset="/wp-content/uploads/2015/07/bathsheba-grossman-lamp.jpg 1000w, /wp-content/uploads/2015/07/bathsheba-grossman-lamp-150x150.jpg 150w, /wp-content/uploads/2015/07/bathsheba-grossman-lamp-300x300.jpg 300w, /wp-content/uploads/2015/07/bathsheba-grossman-lamp-768x768.jpg 768w, /wp-content/uploads/2015/07/bathsheba-grossman-lamp-160x160.jpg 160w, /wp-content/uploads/2015/07/bathsheba-grossman-lamp-320x320.jpg 320w" sizes="(max-width: 1000px) 100vw, 1000px" /><p class="wp-caption-text">Complex Geometric Lamp Designs Produced with 3D Printing (<a href="http://mymodernmet.com/bathsheba-grossman-3d-printed-lamps/">Source</a>)</p></div>
<blockquote><p>The power of mathematics is often to change one thing into another, to change geometry into language. &#8211;Marcus du Sautoy.</p></blockquote>
<p><span class="dropcap">I</span>n <a href="/index.php/2015/09/11/ga-computing1/" target="_blank">the previous post</a> we read how our languages and ideas about the computational universe are best expressed using either a general purpose language with balanced human-computational aspects like Python or using a domain-specific language carefully crafted for our particular domain of abstractions. In this post, we will focus our attention on a specific domain for computation, geometric computing, and the design of geometry-specific programming languages.</p>
<h3>Geometric Computing: The 6th Discipline</h3>
<div id="attachment_794" style="width: 310px" class="wp-caption alignright"><a href="/wp-content/uploads/2015/09/2005Clear_FITNZ_01.jpg" data-rel="lightbox-0" title=""><img class="wp-image-794 size-medium" src="/wp-content/uploads/2015/09/2005Clear_FITNZ_01-300x227.jpg" alt="2005Clear_FITNZ_01" width="300" height="227" srcset="/wp-content/uploads/2015/09/2005Clear_FITNZ_01-300x227.jpg 300w, /wp-content/uploads/2015/09/2005Clear_FITNZ_01.jpg 583w" sizes="(max-width: 300px) 100vw, 300px" /></a><p class="wp-caption-text">The US experience in the development of the academic computing disciplines. Computer Science (CS) and Software Engineering (SE) can be further sub-divided to include Geometric Computing (<a href="http://www.citrenz.ac.nz/bacit/0303/2005Clear_FITNZ.htm">Source</a>)</p></div>
<p>The ACM Computing Curricula 2005<sup class='endnote'><a href='#en-622-1' id='enref-622-1' onclick='return hhEndnotes_show(622)'>1</a></sup> defined &#8220;computing&#8221; as follows:</p>
<blockquote><p>In a general way, we can define computing to mean any goal-oriented activity requiring, benefiting from, or creating computers. Thus, computing includes designing and building hardware and software systems for a wide range of purposes; processing, structuring, and managing various kinds of information; doing scientific studies using computers; making computer systems behave intelligently; creating and using communications and entertainment media; finding and gathering information relevant to any particular purpose, and so on. The list is virtually endless, and the possibilities are vast.</p></blockquote>
<p>The report recognized five prominent sub-disciplines of the computing field: Computer Science (CS), Computer Engineering (CE), Information Systems (IS), Information Technology (IT), and Software Engineering (SE). I strongly believe Geometric Computing (GC) deserves to be added to these five. If we search the internet for the term &#8220;Geometric Computing&#8221; we probably will not find any specific definition. Many even identify &#8220;Geometric Computing&#8221; with &#8220;Computational Geometry&#8221;, which I think is a wrong idea as I will explain shortly. Borrowing from a 1989 ACM report on &#8220;Computing as a Discipline&#8221;<sup class='endnote'><a href='#en-622-2' id='enref-622-2' onclick='return hhEndnotes_show(622)'>2</a></sup> we can adopt the following definition for geometric computing:</p>
<blockquote><p>The discipline of geometric computing is the systematic study of algorithmic processes that describe and transform geometric information: their theory, analysis, design, efficiency, implementation, and application. The fundamental question underlying all geometric computing is &#8220;What (and how) geometric processes can be efficiently automated?&#8221;</p></blockquote>
<p>From a teaching viewpoint, complete undergraduate and postgraduate academic programs should be designed for geometric computing; as is now common for the other five major computing disciplines. Such programs should include:</p>
<ul>
<li>Courses on specialized data structures for efficient geometric information storage, retrieval, and querying, like the ones in <a href="http://www.cs.umd.edu/~hjs/">Prof. Hanan Samet</a>&#8216;s book &#8220;Foundations of Multidimensional and Metric Data Structures &#8220;, in addition to the traditional data structures of linked lists, stacks, queues, trees, graphs, and the like.</li>
<li>A course on Euclidean and non-Euclidean geometries.</li>
<li>A course on differential geometry for geometric modeling.</li>
<li>A course on number theory and its applications in geometric information representation and processing.</li>
<li>A course on numerical representation methods for geometric processing including floating-point numbers, exact numerical representations, and interval arithmetic as we discussed in a <a href="/index.php/2015/08/14/history-of-numbers3/">previous post</a>.</li>
<li>A course on geometric algebra for geometric modeling that we will investigate in following posts.</li>
<li>A course on the properties and generation of geometric fractals.</li>
<li>Courses on computational geometry including the use of libraries like CGAL and LEDA.</li>
<li>Courses on computer graphics including ray tracing and global illumination techniques along with the traditional rendering techniques.</li>
<li>Courses on GPU design and programming for general geometric processing not just for computer graphics.</li>
<li>Courses on data visualization in 2D and 3D.</li>
<li>Courses on DSL design and implementation for geometric computing applications.</li>
<li>Courses on user interface design for geometric computing and geometric modeling software.</li>
<li>Elective courses on applied geometric computing in game engine design, simulation, geographical information systems, robotics, CAD\CAM, computer vision, and other related fields.</li>
</ul>
<p>The mathematical courses in this list, like Euclidean and non-Euclidean geometries, differential geometry, geometric algebra, and number theory, should be taught as introductions with emphasis on applications not mathematical rigor; similar to how we are teaching Fourier and Laplace transforms in electrical engineering courses for example. Many career opportunities are waiting for graduates of such geometric computing programs; just have a look <a href="http://study.com/articles/Graphics_Engineer_Job_Description_Duties_and_Requirements.html">here</a> to get a general idea. Most traditional computing teaching programs do not provide specific training for these important and fast growing career paths. A well designed geometric computing teaching program will create more advancement opportunities for both students and markets. I hope that someday I will have the opportunity to be one of the designers of a geometric computing academic teaching program.</p>
<h3>Computational Geometry Out of the Way</h3>
<p>In the light of the previous discussion, it was strange for me as a software engineer to find that most researchers in <a href="https://en.wikipedia.org/wiki/Computational_geometry">computational geometry</a> consider it equivalent to geometric computing. In the 1970s the ﬁeld of computational geometry emerged, dealing with geometric problems requiring carefully designed geometric algorithms for their solution. It can be deﬁned as the systematic study of algorithms and data structures for geometric objects, with a focus on exact algorithms that are asymptotically fast. Many researchers were attracted by the challenges posed by the geometric problems. The road from problem formulation to efficient and elegant solutions has often been long, with many difficult and sub-optimal intermediate results. Today there is a rich collection of geometric algorithms that are efficient, and relatively easy to understand and implement. the algorithmic problems solved by computational geometry can be found in various application areas including robotics, computer graphics, CAD/CAM, integrated circuit design, computer vision, mesh generation for computer-aided engineering, and geographic information systems<sup class='endnote'><a href='#en-622-3' id='enref-622-3' onclick='return hhEndnotes_show(622)'>3</a></sup>.</p>
<div id="attachment_773" style="width: 310px" class="wp-caption alignright"><a href="/wp-content/uploads/2015/09/bunnyboy.jpg" data-rel="lightbox-1" title=""><img class="size-medium wp-image-773" src="/wp-content/uploads/2015/09/bunnyboy-300x241.jpg" alt="bunnyboy" width="300" height="241" srcset="/wp-content/uploads/2015/09/bunnyboy-300x241.jpg 300w, /wp-content/uploads/2015/09/bunnyboy-768x616.jpg 768w, /wp-content/uploads/2015/09/bunnyboy.jpg 808w" sizes="(max-width: 300px) 100vw, 300px" /></a><p class="wp-caption-text">Ray tracing is an example of a geometric computing problem where algorithmic complexity is deceiving. (<a href="https://viscomp.alexandra.dk/?p=278">Source</a>)</p></div>
<p>Geometric computing is not just about finding algorithms with good complexity, this is just the &#8220;theoretical&#8221; aspect of geometric computing; one outstanding example of this fact in computer graphics is <a href="https://en.wikipedia.org/wiki/Ray_tracing_(graphics)">ray tracing</a>. Because each ray is evaluated independently from the rest, ray tracing is “embarrassingly parallel,” with more processors being thrown at the problem usually giving a nearly linear performance increase. Ray tracing also has another interesting feature, that the time for finding the closest (or for shadows, any) intersection<sup class='endnote'><a href='#en-622-4' id='enref-622-4' onclick='return hhEndnotes_show(622)'>4</a></sup> for a ray is typically order O(log n) for n objects, when an efficiency structure is used, like <a href="https://en.wikipedia.org/wiki/Bounding_volume_hierarchy">bounding volume hierarchies</a> for example. This compares well with the typical O(n) performance of the basic <a href="https://en.wikipedia.org/wiki/Z-buffering">Z-buffer</a>, in which all polygons have to be sent down the <a href="https://fgiesen.wordpress.com/2011/07/09/a-trip-through-the-graphics-pipeline-2011-index/">graphics pipeline</a>. Techniques such as <a href="https://www.cg.tuwien.ac.at/research/vr/chcull/bittner-eg04-chcull.pdf">hierarchical culling</a>, <a href="https://en.wikipedia.org/wiki/Level_of_detail">level of detail</a>, and <a href="http://graphics.cs.yale.edu/site/sites/files/EG99-Decoret.pdf">impostors</a> can be used to speed up the Z-buffer to give it a more O(log n) response. With ray tracing, this performance comes with its efficiency scheme, with minimal user intervention. Strangely enough, the main practical problem with ray tracing compared to raster graphics rendering is simply speed. The problem ray tracing faces is that, while O(log n) is better <em><strong>in theory</strong></em> than O(n), <em><strong>in practice</strong></em> each of these values is multiplied by a different constant, representing how much time each takes. For example, if ray tracing a single object is 1000 times slower than rendering it with a naive Z-buffer, 1000 log n = n, so at n = 9119 objects ray tracing’s time complexity advantage would allow it to start to outperform a simplistic Z-buffer renderer. One advantage of the Z-buffer is its use of coherence, sharing results to generate a set of fragments from a single triangle. As scene complexity rises, this factor loses importance. For this reason ray tracing is a viable alternative for extremely large model visualization<sup class='endnote'><a href='#en-622-5' id='enref-622-5' onclick='return hhEndnotes_show(622)'>5</a></sup>. The selection of which computational rendering technique to use is largely dependent on the details of the application not just the theoretical time-complexity of the computational algorithm.</p>
<div id="attachment_638" style="width: 310px" class="wp-caption alignright"><a href="/wp-content/uploads/2015/08/triangulation3.png" data-rel="lightbox-2" title=""><img class="size-medium wp-image-638" src="/wp-content/uploads/2015/08/triangulation3-300x105.png" alt="triangulation3" width="300" height="105" srcset="/wp-content/uploads/2015/08/triangulation3-300x105.png 300w, /wp-content/uploads/2015/08/triangulation3-768x268.png 768w, /wp-content/uploads/2015/08/triangulation3.png 800w" sizes="(max-width: 300px) 100vw, 300px" /></a><p class="wp-caption-text">3D Triangulation in the CGAL Computational Geometry Library (<a href="https://doc.cgal.org/latest/Triangulation_3/">Source</a>)</p></div>
<p>The two most notable software libraries for computational geometry are <a href="https://www.cgal.org/">The Computational Geometry Algorithms Library</a> (CGAL) and <a href="http://www.algorithmic-solutions.com/leda/index.htm">The Library of Efficient Data types and Algorithms</a> (LEDA); they reveal another distinction between computational geometry and geometric computing. Geometric computing is a form of geometry-specific software development. In geometric computing we can never be satisfied by a single library to say it&#8217;s equally suitable for all applications requiring geometric data representation and processing. Each geometric computing application has its unique characteristics and domain of ideas that deserves special care and requires unique software architecture. A computational geometry library like CGAL or LEDA can be a part of such architecture but it&#8217;s not the only part or even the only important part; the usability of the geometric computing application is certainly determined by many other factors. In this context computational geometry can benefit geometric computing as a general utility for rapid prototyping; computational geometry can, at the same time, benefit from geometric computing developments as well. Many practical concerns for creating computational geometry software are actually more related to general software engineering than to algorithmic complexity as we will see shortly; computational geometry libraries can be re-organized to deliver better performance for their computational aspect while being more accessible for their human aspect. Creating better geometric computing methodologies, practices, and DSLs can make libraries for computational geometry, robotics, computer graphics, and other geometric computing applications more accessible and practical to use.</p>
<h3>Geometric State vs Geometric Action</h3>
<p>In the English language, there are two kinds of verbs: <a href="http://www.grammaring.com/state-verbs-and-action-verbs">State verbs and Action verbs</a>.</p>
<ul>
<li><strong>State verbs</strong> express states or conditions which are relatively static. They include verbs of perception, cognition, the senses, emotion and state of being, like appear, believe, consist, contain etc. State verbs are not normally used in continuous forms. For example, we don&#8217;t say: &#8220;I am needing a new phone&#8221; but we can say: &#8220;I need a new phone&#8221;.</li>
<li><strong>Action verbs</strong> (also called dynamic verbs) express activities, processes, momentary actions or physical conditions like knock, leave, melt, read, etc. They may be used in continuous forms, for example: &#8220;Someone&#8217;s knocking at the door&#8221;.</li>
</ul>
<p>A very similar situation can be found in our internal language of geometric reasoning, even if we&#8217;re not conscious enough about it most of the time. In all our geometric models we always have state geometric constructs and action geometric constructs:</p>
<ul>
<li><strong>State geometric constructs</strong> contain key geometric information we need to store and change during the normal operation of the model. Two important examples found in computer graphics, robotics, and computer vision include position vectors (that represent points\locations in space) and frames (that represent poses\orientations of rigid bodies in space).</li>
<li><strong>Action geometric constructs</strong> contain processing information to move the model components between geometric states. For example, a direction vector can be used to move from one point to the other, and a rotation\translation matrix can be used to move from one orientation frame to another.</li>
</ul>
<p>The mathematical tools used for representing these two very different types of geometric constructs are, unfortunately more often than not, mixed without proper investigation of consequences. For example, we use the same 3-tuples of numbers to represent both positions (states) and directions (actions) in 3D Euclidean geometric models. Another example is the use of unit quaternions and rotation matrices to represent both orientations (states) and rotations (actions). The main problem here is the different geometric semantics of states and actions that should be reflected in their proper mathematical representations. For example, a direction vector is translation invariant while a position vector is not, we can interpolate rotations naturally but the same operation for orientations is not well defined. This situation is very common in practical geometric computing software implementations, typically leading to many special cases and parametric singularities that need to be specifically handled. Such mixing of state\action representations increase difficulty for debugging and creating modular geometric computing code <sup class='endnote'><a href='#en-622-6' id='enref-622-6' onclick='return hhEndnotes_show(622)'>6</a></sup>.</p>
<h3>Geometry &gt; Algebra &gt; Algorithm &gt; Code</h3>
<div id="attachment_827" style="width: 310px" class="wp-caption alignright"><a href="/wp-content/uploads/2015/09/ldc3.jpg" data-rel="lightbox-3" title=""><img class="size-medium wp-image-827" src="/wp-content/uploads/2015/09/ldc3-300x214.jpg" alt="ldc3" width="300" height="214" srcset="/wp-content/uploads/2015/09/ldc3-300x214.jpg 300w, /wp-content/uploads/2015/09/ldc3.jpg 582w" sizes="(max-width: 300px) 100vw, 300px" /></a><p class="wp-caption-text">The road from abstract geometric ideas to concrete computer code is hard but rewarding. (<a href="http://blog.hvidtfeldts.net/index.php/category/mathematical-art/">Source</a>)</p></div>
<p>Geometry is essentially a visual and imaginative human activity, it&#8217;s mathematically modeled using the language of algebra, computational algorithms are derived from the algebra and geometry, and finally software is coded from the algorithms. Each step of these four is a world of challenge and creativity in its own<sup class='endnote'><a href='#en-622-7' id='enref-622-7' onclick='return hhEndnotes_show(622)'>7</a></sup>:</p>
<ol>
<li>First of all, we need to be geometrically imaginative, to think and reason in geometry; this requires talent and training like any other form of human art<sup class='endnote'><a href='#en-622-8' id='enref-622-8' onclick='return hhEndnotes_show(622)'>8</a></sup>!</li>
<li>Next, we need to select suitable algebraic representations for our geometric objects and algebraic operations for the geometric processing we which to apply. Some representations are purely algebraic, like implicit and parametric equations for curves and surfaces. More often geometric representations are combinatorial in nature, an object is represented as a collection of simpler objects and a set of constraints on them. Take a look at the following question: given a circle of radius r, what is the locus of this circle if its center moves on a curve? We know that the locus, usually referred to as a sweep, looks like a tube; but, it is not so easy to know what exactly this tube looks like. If the curve is a line normal to the plane of the circle, the locus is a right cylinder. The difficult part is that the curve is not a line and/or that the radius of the given circle can change. Therefore, we have an easily described geometric operation whose algebraic counterpart is somewhat complicated.</li>
<li>Some algorithms are straight forward to derive from the algebraic representations; for example finding the intersection point (or verifying there exists one) of two lines in 2D given their implicit equations. The general case is far from simple, however, and a combination of symbolic, numeric, approximate, and geometric processes are applied to find a fully functional computational algorithm.</li>
<li>The final step, that many erroneously choose to ignore initially as being straight forward, is coding the algorithm into working software. Translating geometric algorithms to programs requires extreme care in each step: from the correct selection of a <a href="/index.php/2015/08/14/history-of-numbers3/">number system</a> to represent and store geometric data with acceptable accuracy, to the handling of special cases of the algorithm, and designing a suitable user interface that actually works for the specific application. In addition, the exact same algorithm may be generally coded using a universal matrix algebra library, or specifically coded for a few special cases depending on the requirements of the application.</li>
</ol>
<h3>Moving from Abstract to Concrete</h3>
<div id="attachment_808" style="width: 450px" class="wp-caption alignright"><a href="/wp-content/uploads/2015/09/Gram-Schmidt_orthonormalization_process.gif" data-rel="lightbox-4" title=""><img class="size-full wp-image-808" src="/wp-content/uploads/2015/09/Gram-Schmidt_orthonormalization_process.gif" alt="Gram-Schmidt_orthonormalization_process" width="440" height="330" /></a><p class="wp-caption-text">The modified Gram-Schmidt process on 3 vectors.</p></div>
<p>When we move from the most abstract level of geometric thinking to the most concrete level of software coding we face many questions. Taking the <a href="https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process">Gram–Schmidt process</a> for converting a set of linearly independent vectors into a set of orthonormal vectors of the same finite size as a very simple example. First we define the projection operator of one vector <strong>v</strong> on another vector <strong>u</strong> by:</p>
<p><a href="/wp-content/uploads/2015/09/gco-1.png" data-rel="lightbox-5" title=""><img class="alignnone size-full wp-image-812" src="/wp-content/uploads/2015/09/gco-1.png" alt="gco-1" width="171" height="47" /></a></p>
<p>Then the procedure goes as follows:</p>
<p><a href="/wp-content/uploads/2015/09/gco-2.png" data-rel="lightbox-6" title=""><img class="alignnone size-full wp-image-813" src="/wp-content/uploads/2015/09/gco-2.png" alt="gco-2" width="527" height="292" srcset="/wp-content/uploads/2015/09/gco-2.png 527w, /wp-content/uploads/2015/09/gco-2-300x166.png 300w" sizes="(max-width: 527px) 100vw, 527px" /></a></p>
<p>We need to carefully study some points to implement this algebraic algorithm successfully:</p>
<p><strong>Input\Output Representation.</strong> The basic geometric components of this problem are n linear independent vectors (the inputs) and n orthonormal vectors (the outputs). How are we given the inputs and how should we deliver the outputs? Many options exist including using tuples, using single row-or column matrices, or using a class\structure with x,y, and z components (if our vectors are in 3D). In addition, which computational number system should we use for the vector components? Exact rational numbers, floating-point numbers, etc. Another important consideration is whether to use classes or structures (i.e. using the <a href="https://www.dotnetperls.com/struct-versus-class">heap or the stack</a>) for concrete vectors; both methods are algorithmically equivalent but are very different implementation-wise.</p>
<p><strong>Sub-Process Representation.</strong> The basic algebraic operations on the vectors throughout the process are vector projection on another vector, vector normalization, the inner product of two vectors, vector subtraction, and vector scaling by a number. A typical OOP way of thinking would define each operation in a separate subroutine and call the inner product subroutine from the projection subroutine, the projection subroutine from the main loop subroutine, and so on; this is not the most efficient implementation, however, we will see why in the following points to come.</p>
<p><strong>Intermediate Results Representation.</strong> During our computational processes, many intermediate results are required. Depending on the nature of the computation some results persist until the end and some are just needed for a few steps. Typical OOP would use the same representation for all geometric objects (in this case vectors) of the problem whether being input, output, or intermediate objects especially inside the isolated subroutines for the basic sub-processes. This would probably lead to many stack\heap allocations damaging the net performance of the implementation. This is one crucial difference between geometric procedure and software subroutine. The design of the intermediate results representation should be considered carefully under many possible domain-specific optimizations.</p>
<div id="attachment_820" style="width: 310px" class="wp-caption alignright"><a href="/wp-content/uploads/2015/09/csg-tree.png" data-rel="lightbox-7" title=""><img class="size-medium wp-image-820" src="/wp-content/uploads/2015/09/csg-tree-300x266.png" alt="csg-tree" width="300" height="266" srcset="/wp-content/uploads/2015/09/csg-tree-300x266.png 300w, /wp-content/uploads/2015/09/csg-tree.png 677w" sizes="(max-width: 300px) 100vw, 300px" /></a><p class="wp-caption-text">Constructive Solid Geometry (CSG) uses combinatorial trees to represent geometry. (<a href="https://mit-crpg.github.io/OpenMOC/methods/constructive_solid_geometry.html">Source</a>)</p></div>
<p><strong>Geometric Primitives Selection.</strong> Most geometric representations are combinatorial in nature. But what primitives should be combined to generate the conceptual geometric objects? We find many typical examples including point clouds, triangular meshes, NURBS, subdivision surfaces, circles, spheres, cubes, and much more. No single selection of primitives is suitable for all geometric computing applications. For example, <a href="http://www.openscad.org/">3D CSG modeling software</a> typically uses solids like cones, spheres, boxes, and similar primitives. Then the software internally transforms these into triangular meshes or point clouds for data storage and exchange with other software systems. Other applications like 3D laser scanning and <a href="https://en.wikipedia.org/wiki/Lidar">LIDAR</a> remote sensing initially generate huge volumes of point clouds that need grouping and processing to be humanly accessible. How can we select and manipulate the best set of primitives for our geometric computing application is an important aspect.</p>
<p>&nbsp;</p>
<div id="attachment_829" style="width: 310px" class="wp-caption alignright"><a href="/wp-content/uploads/2015/09/World-scenegraph.png" data-rel="lightbox-8" title=""><img class="size-medium wp-image-829" src="/wp-content/uploads/2015/09/World-scenegraph-300x239.png" alt="World-scenegraph" width="300" height="239" srcset="/wp-content/uploads/2015/09/World-scenegraph-300x239.png 300w, /wp-content/uploads/2015/09/World-scenegraph.png 536w" sizes="(max-width: 300px) 100vw, 300px" /></a><p class="wp-caption-text">The Scene Graph is the largest, most important combinatorial representation in modern computer graphics. (<a href="http://theknextedmind.blogspot.com.eg/2013/09/if-i-made-graph-of-what-my-eyes-see-can.html">Source</a>)</p></div>
<p><strong>Combinatorial Depth.</strong> When trying to represent a simple geometric concept like a line we have many choices. We can use two point objects, one point and one unit vector objects, a set of numbers for the line&#8217;s <a href="https://en.wikipedia.org/wiki/Pl%C3%BCcker_coordinates">Plücker coordinates</a>, a simple set of 6 numbers (x1, y1, z1, x2, y2, z2) for the two points of the line, and much more. Now we can represent a plane as a combinatorial tree of one line and one point, or as a simple list of 9 numbers (the coordinates of the plan&#8217;s three points). Each representation selection is a combination of other geometric objects. We then can choose to create &#8220;deep&#8221; or &#8220;shallow&#8221; combinatorial trees for complex objects. How deep should we allow our representations to go will affect performance, code readability and maintenance, and data storage and exchange capabilities. Deep representations are good for human understanding while shallow implementations are better for low-level computing provided that we can write, or generate, the code for manipulating them.</p>
<div id="attachment_831" style="width: 310px" class="wp-caption alignright"><a href="/wp-content/uploads/2015/09/method01.png" data-rel="lightbox-9" title=""><img class="size-medium wp-image-831" src="/wp-content/uploads/2015/09/method01-300x118.png" alt="method01" width="300" height="118" srcset="/wp-content/uploads/2015/09/method01-300x118.png 300w, /wp-content/uploads/2015/09/method01.png 753w" sizes="(max-width: 300px) 100vw, 300px" /></a><p class="wp-caption-text">Different representations for different geometric computing algorithms. (<a href="https://www.nogrid.com/index.php">Source</a>)</p></div>
<p><strong>Mixing Representations.</strong> Even the simplest of abstract geometric objects have many representations. Mixing a parametric and implicit representation for circles, for example, inside the same software can be useful for implementing different algorithms that work well for different representations. For example, point generation algorithms are trivial for parametric representations while incidence queries are easier for implicit representations. How should we code such multiple representations? One choice is to create a base class, for example, &#8220;Circle&#8221;, and inherit several representations from it (CircleP and CircleI) implementing specific algorithms on the child classes and automatically selecting, and converting to, the most suitable representation for a given algorithm. Another choice is to use a standard canonical representation for all objects (like <a href="https://en.wikipedia.org/wiki/Boundary_representation">BREP</a> for geometric surfaces) and apply automatic conversions at each computational step of our algorithms. A third choice is by creating separate representation classes and let the user explicitly enforce what representation to use for a given algorithm and control conversion process manually. Each choice of the three has its benefits and problems.</p>
<div id="attachment_818" style="width: 310px" class="wp-caption alignright"><a href="/wp-content/uploads/2015/09/compiler.png" data-rel="lightbox-10" title=""><img class="size-medium wp-image-818" src="/wp-content/uploads/2015/09/compiler-300x195.png" alt="compiler" width="300" height="195" srcset="/wp-content/uploads/2015/09/compiler-300x195.png 300w, /wp-content/uploads/2015/09/compiler-768x500.png 768w, /wp-content/uploads/2015/09/compiler.png 813w" sizes="(max-width: 300px) 100vw, 300px" /></a><p class="wp-caption-text">Modern general purpose compilers perform complicated low-level optimizations but fail to make domain-level optimizations. (<a href="http://www.rtcmagazine.com/articles/view/103234">Source</a>)</p></div>
<p><strong>Domain-Level Optimizations.</strong> A typical modern <a href="https://en.wikipedia.org/wiki/Optimizing_compiler">optimizing compiler</a> for a general purpose programming language can generate and optimize the final machine code very well if the code exhibits locality (for example belongs to the same subroutine). Compilers can eliminate many local low-level computational redundancies but have no clue at possible high-level, more abstract optimizations especially when the computational algorithm implementation is scattered across several classes and subroutines. In my experience high-level domain specific optimizations are more critical to performance than low-level code optimizations. To approach these we need a solid understanding of the details of our geometric algorithm and even then we often miss a lot of possible optimizations. In addition, performing manual domain-level optimization is too difficult and error prone to be carried to its full extent. It&#8217;s sometimes possible to optimize the algorithm as a whole by uniformly representing its objects and processes using the &#8220;shallowest&#8221; possible combinatorial tree representations; now we are dealing with a set of arithmetic number computations that can be expressed as an easy to optimize, very low-level, and large directed graph. This approach is partially possible using code generation and geometric algebra as I will explain in later posts and illustrate throughout this web site.</p>
<div id="attachment_824" style="width: 283px" class="wp-caption alignright"><a href="/wp-content/uploads/2015/09/NBBJ_HANGZHOU_STADIUM.jpg" data-rel="lightbox-11" title=""><img class="size-medium wp-image-824" src="/wp-content/uploads/2015/09/NBBJ_HANGZHOU_STADIUM-273x300.jpg" alt="NBBJ_HANGZHOU_STADIUM" width="273" height="300" srcset="/wp-content/uploads/2015/09/NBBJ_HANGZHOU_STADIUM-273x300.jpg 273w, /wp-content/uploads/2015/09/NBBJ_HANGZHOU_STADIUM.jpg 545w" sizes="(max-width: 273px) 100vw, 273px" /></a><p class="wp-caption-text">Procedural geometry using Grasshopper on Rhino (<a href="http://www.grasshopper3d.com/photo/nbbj-ccdi-hangzhou-stadium?context=featured">Source</a>)</p></div>
<p><strong>Rapid Prototyping.</strong> If we have a geometric idea that we need to explore and we have to wait for several days until suitable code is written so that we can see how it goes we would probably go find better things to do instead. Rapid prototyping is very important for practical geometric thinking and realization of ideas. The success of <a href="https://en.wikipedia.org/wiki/List_of_interactive_geometry_software">interactive geometry software</a> like <a href="https://cinderella.de/tiki-index.php">Cinderella</a>, <a href="http://www.dynamicgeometry.com/">The Geometer&#8217;s Sketchpad</a>, and <a href="https://www.geogebra.org/">GeoGebra</a> in teaching and exploring geometry is one pointer to the importance of rapid prototyping in geometric computing. One other remarkable success story is <a href="http://www.grasshopper3d.com/">Grasshopper</a> on <a href="http://www.rhino3d.com/features">Rhino</a>, a very interesting visual DSL for procedural creation of complex 3D geometric constructions using intuitive geometric computing visual blocks that has vast practical use in art, design, and architecture<sup class='endnote'><a href='#en-622-9' id='enref-622-9' onclick='return hhEndnotes_show(622)'>9</a></sup> <sup class='endnote'><a href='#en-622-10' id='enref-622-10' onclick='return hhEndnotes_show(622)'>10</a></sup>.</p>
<p><strong>Process Testing and Debugging.</strong> In modern software, we need test cases to find bugs in our system. The problem with geometric algorithms is the many special cases that might not be obvious form the start. In this particular example, one special case is when some of the input vectors are (completely or nearly) linearly dependent when one or more are near zero, or when large variations in vector lengths are present in the input vectors; we need to study these special cases carefully to design our test code. In addition, stepping through the code while being executed is of little benefit; we need strong visual clues for each step of the computation; after all we a, e dealing with geometric computing that is visual by nature in most aspects. We also need algebraic assertions with significant geometric meaning; for example after finishing the orthogonalization procedure we may get the dot-product of each pair of output vectors and assert it&#8217;s very near to zero. Designing suitable tests is fundamental to geometric computing just like to any software system development.</p>
<div id="attachment_833" style="width: 310px" class="wp-caption alignright"><a href="/wp-content/uploads/2015/09/symmetry3d.jpg" data-rel="lightbox-12" title=""><img class="size-medium wp-image-833" src="/wp-content/uploads/2015/09/symmetry3d-300x210.jpg" alt="symmetry3d" width="300" height="210" srcset="/wp-content/uploads/2015/09/symmetry3d-300x210.jpg 300w, /wp-content/uploads/2015/09/symmetry3d.jpg 500w" sizes="(max-width: 300px) 100vw, 300px" /></a><p class="wp-caption-text">Geometric symmetries are not preserved when using floating-point arithmetic. (<a href="http://www.numeracy-bank.net/?q=t/mea/ssg/4">Source</a>)</p></div>
<p><strong>Geometric Representation\Process Invariance and Computation Time. </strong>Geometry is symmetric by nature, the selection of the coordinate system is arbitrary, at least in theory, to enable using n-tuple computational representations for vectors on a given basis. This is called coordinate-free geometry, or more accurately coordinate-invariant. Practically, this ideal is almost impossible to achieve but we, the geometry implementers, tend to live with the problem. For example, computing with floating-point numbers makes it impossible to preserve the invariance of the Gram–Schmidt process for any arbitrary basis, but guarantees near constant computation time for the same number of input vectors. If we use exact arithmetic, the computation time for, say, 3 vectors depends on the relative relation between the vectors in space and the selected basis (axis); now process invariance is computationally preserved, but computation time is varying widely because of the use of exact numeric computations. This problem is central to implementing many geometric computing systems even if the computational geometry algorithm is well-studied to be algorithmically efficient. A form of stability analysis for the computational algorithm in terms of accuracy and time requirements is needed. In the terminology of Modeling and Simulation, this process is generally called system <a href="https://en.wikipedia.org/wiki/Accreditation">accreditation</a>.</p>
<p><strong>Numerical Error Control.</strong> Many geometric processes are very sensitive to numerical errors. If you try to find the intersection point of two lines in 3D represented by the coordinates of two points each, a total of 12 numbers, any small error in any of the 12 numbers will result in two non-intersecting lines. Exact equality testing is not a good idea in such cases but interval inclusion is usually used instead. Some case studies exist for showing the severity of this problem for geometric algorithms implementations like the ones <a href="https://people.mpi-inf.mpg.de/~kettner/proj/NonRobust/index.html">here</a> and <a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-766.pdf">here</a>.</p>
<div id="attachment_836" style="width: 310px" class="wp-caption alignright"><a href="/wp-content/uploads/2015/09/cloth_simulation_in_blender_by_shyngyskhan-d85k74g.png" data-rel="lightbox-13" title=""><img class="size-medium wp-image-836" src="/wp-content/uploads/2015/09/cloth_simulation_in_blender_by_shyngyskhan-d85k74g-300x169.png" alt="cloth_simulation_in_blender_by_shyngyskhan-d85k74g" width="300" height="169" srcset="/wp-content/uploads/2015/09/cloth_simulation_in_blender_by_shyngyskhan-d85k74g-300x169.png 300w, /wp-content/uploads/2015/09/cloth_simulation_in_blender_by_shyngyskhan-d85k74g-768x432.png 768w, /wp-content/uploads/2015/09/cloth_simulation_in_blender_by_shyngyskhan-d85k74g-1024x576.png 1024w" sizes="(max-width: 300px) 100vw, 300px" /></a><p class="wp-caption-text">Collision detection, a very important geometric query, can be used for cloth simulation. (<a href="http://shyngyskhan.deviantart.com/art/Cloth-Simulation-in-Blender-493069840">Source</a>)</p></div>
<p><strong>Query vs. Compute Consistency.</strong> Due to bad selection of basic numeric representations or bad algorithm design many query algorithms return different results from their corresponding computation algorithms. For example one may create query code to test if two given lines intersect in 3D that answers true for some input, while the computation code for finding the actual intersection point fails. This is a very serious problem that requires special care for implementing consistent query-computation code especially for special cases in geometric computing.</p>
<p>&nbsp;</p>
<div id="attachment_838" style="width: 310px" class="wp-caption alignright"><a href="/wp-content/uploads/2015/09/fgworkshop-software-vulnerability-49-638.jpg" data-rel="lightbox-14" title=""><img class="size-medium wp-image-838" src="/wp-content/uploads/2015/09/fgworkshop-software-vulnerability-49-638-300x225.jpg" alt="fgworkshop-software-vulnerability-49-638" width="300" height="225" srcset="/wp-content/uploads/2015/09/fgworkshop-software-vulnerability-49-638-300x225.jpg 300w, /wp-content/uploads/2015/09/fgworkshop-software-vulnerability-49-638.jpg 638w" sizes="(max-width: 300px) 100vw, 300px" /></a><p class="wp-caption-text">Pointer arithmetic and array bounds checking. (<a href="https://www.slideshare.net/fg_informatik/fgworkshop-software-vulnerability">Source</a>)</p></div>
<p><strong>Using Arrays, Loops, and Indirect Memory Access.</strong> Many direct implementations of geometric algorithms rely on looping, arrays, and other indirect memory access schemes; this should be avoided as much as possible. For example if we need to compute Gram–Schmidt process for only 3D vectors we should create a structure with 3 members not a single array of 3 elements. The reason for that is the access of local variables takes less instructions than accessing array items that may require indirect memory access (i.e. pointer arithmetic) and array bounds checks. The difference may seem insignificant at first but anyone who created a game engine or a real time flight simulator knows it&#8217;s not; every processor cycle counts. Writing the manual code will get more difficult but performance will be better than using a for loop on an array, as the case for inner product computation for example. The problem of manual coding in such case can be easily solved using automatic code generation techniques.</p>
<h3>A Geometric Computing Conclusion</h3>
<p>In this post, I tried to give a definition to Geometric Computing as a very important but currently very scattered discipline of computing deserving the development of specialized teaching programs. I tried to differentiate and relate geometric computing and computational geometry. I also tried to describe the steps involved in creating a concrete software implementation from our abstract geometric ideas. Finally, I gave a list of some significant problems we need to answer when designing geometric computing software. In the next posts, I will try to describe how good use of Geometric Algebra and some standard software engineering methods can address many of the problems listed in this post. Until next time, I hope you follow and enjoy.</p>
<p><a href="/wp-content/uploads/2015/09/done6.png" data-rel="lightbox-15" title=""><img class="alignright size-medium wp-image-840" src="/wp-content/uploads/2015/09/done6-300x40.png" alt="done6" width="300" height="40" /></a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr />
<p>&nbsp;</p>
<div class='endnotes' id='hhendnotes-622'>
<ol>
<li id='en-622-1'>The Joint Task Force for Computing Curricula 2005, &#8220;Computing Curricula 2005: The Overview Report&#8221;. <a href="http://www.acm.org/education/curricula-recommendations">Online</a> <span class='endnotereverse'><a href='#enref-622-1'>&#8617;</a></span></li>
<li id='en-622-2'>D. E. Comer et al, &#8220;Computing As a Discipline&#8221;. Community ACM Vol. 32. Num. 1, January 1989 <span class='endnotereverse'><a href='#enref-622-2'>&#8617;</a></span></li>
<li id='en-622-3'>Mark de Berg, Otfried Cheong, Marc van Kreveld, &#8220;Computational Geometry, Algorithms and Applications, Third Edition&#8221;. Springer 2008 <span class='endnotereverse'><a href='#enref-622-3'>&#8617;</a></span></li>
<li id='en-622-4'>Intersection computations is the main geometric operation in ray tracing that requires most of the processing time <span class='endnotereverse'><a href='#enref-622-4'>&#8617;</a></span></li>
<li id='en-622-5'>Tomas Akenine-Moller, Eric Haines, Naty Hoffman, &#8220;Real-Time Rendering, Third Edition 3rd Edition&#8221;. CRC Press 2008 <span class='endnotereverse'><a href='#enref-622-5'>&#8617;</a></span></li>
<li id='en-622-6'>For more information about this important topic you can read any book on <a href="https://en.wikipedia.org/wiki/Affine_space">Affine Geometry</a> in computer graphics like &#8220;An Integrated Introduction to Computer Graphics and Geometric Modeling&#8221; by Ronald Goldman, and this good paper on the problems of representing rotations and orientations in geometric computing <a href="http://mrl.snu.ac.kr/publications/RotationAndOrientation.pdf">here</a> <span class='endnotereverse'><a href='#enref-622-6'>&#8617;</a></span></li>
<li id='en-622-7'>Take a look at the theme of the <a href="http://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/overview/theme.html">online course notes</a> on &#8220;Computing with Geometry&#8221; by Dr. Ching-Kuang Shene <span class='endnotereverse'><a href='#enref-622-7'>&#8617;</a></span></li>
<li id='en-622-8'>To get an idea about how geometric thinking works, see the book edited by Sue Johnston-Wilder and John Mason, &#8220;Developing Thinking in Geometry&#8221;. SAGE Publications Ltd 2005 <span class='endnotereverse'><a href='#enref-622-8'>&#8617;</a></span></li>
<li id='en-622-9'>See <a href="https://www.youtube.com/watch?v=78swuEr7dtY" data-rel="lightbox-video-0">this video</a> for an illustration and see <a href="http://www.grasshopper3d.com/photo/photo/listFeatured">here</a> for more Grasshopper featured galleries <span class='endnotereverse'><a href='#enref-622-9'>&#8617;</a></span></li>
<li id='en-622-10'>One other very interesting use of Rhino was accomplished using functional programming with F# for designing the Cladding of the <a href="https://en.wikipedia.org/wiki/Louvre_Abu_Dhabi">Louvre Abu Dhabi Dome</a>; see <a href="http://fsharp.org/testimonials/#goswin-1">here</a> for some details <span class='endnotereverse'><a href='#enref-622-10'>&#8617;</a></span></li>
</ol>
</div>
<p><a class="a2a_button_facebook" href="https://www.addtoany.com/add_to/facebook?linkurl=%2Findex.php%2F2015%2F09%2F18%2Fga-computing2%2F&amp;linkname=Computing%20for%20Geometry%3A%20When%20the%20Going%20Gets%20Tough%20%E2%80%A6" title="Facebook" rel="nofollow noopener" target="_blank"></a><a class="a2a_button_twitter" href="https://www.addtoany.com/add_to/twitter?linkurl=%2Findex.php%2F2015%2F09%2F18%2Fga-computing2%2F&amp;linkname=Computing%20for%20Geometry%3A%20When%20the%20Going%20Gets%20Tough%20%E2%80%A6" title="Twitter" rel="nofollow noopener" target="_blank"></a><a class="a2a_button_google_plus" href="https://www.addtoany.com/add_to/google_plus?linkurl=%2Findex.php%2F2015%2F09%2F18%2Fga-computing2%2F&amp;linkname=Computing%20for%20Geometry%3A%20When%20the%20Going%20Gets%20Tough%20%E2%80%A6" title="Google+" rel="nofollow noopener" target="_blank"></a><a class="a2a_dd addtoany_share_save" href="https://www.addtoany.com/share#url=%2Findex.php%2F2015%2F09%2F18%2Fga-computing2%2F&amp;title=Computing%20for%20Geometry%3A%20When%20the%20Going%20Gets%20Tough%20%E2%80%A6" data-a2a-url="/index.php/2015/09/18/ga-computing2/" data-a2a-title="Computing for Geometry: When the Going Gets Tough …"></a></p><p>The post <a rel="nofollow" href="/index.php/2015/09/18/ga-computing2/">Computing for Geometry: When the Going Gets Tough &#8230;</a> appeared first on <a rel="nofollow" href="/">Geometric Algebra Explorer</a>.</p>
]]></content:encoded>
			</item>
	</channel>
</rss>
